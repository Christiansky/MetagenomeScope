OK, so right now we have two types of collapsing:
	-Global Collapsing (collapsing every compound node in the graph)
	-Local Collapsing (collapse a single node in the graph)

Global collapsing was working fine, but now it's broken because it and local
collapsing don't work particularly well together.

ONE SOLUTION to this:

-Right after the graph has been rendered, record all compound nodes in a 
cy.scratch() list of "uncollapsed compound nodes." You don't have to remove
anything at this point, so this shouldn't be that expensive even for large graphs.

-When an individual node is collapsed (using right-click), add it to another
cy.scratch() list of "collapsed compound nodes" and remove it from the
"uncollapsed" list.

-When an individual node is uncollapsed (using right-click), add it to the
"uncollapsed" list and remove it from the "collapsed" list -- same deal as
above, generally.

-When the user presses the "collapse all node groups" button, instead of
iterating through all nodes in the graph to find compound nodes and then
iterating through those nodes, just iterate through the list of uncollapsed
compound nodes and collapse those. This should be 1) more efficient than
before and 2) easier to understand than before. Any nodes that the user
already collapsed will just be, uh, already collapsed -- so things will be
okay, since those nodes will be in the exact same scenario as any nodes that
will be collapsed globally.

-When the user presses the "uncollapse all node groups" button, just iterate
through the list of collapsed compound nodes and collapse those. Same deal as
above, essentially.

However, another problem occurs that is directly linked to local collapsing.
Say you have two compound nodes, A(a, b, c, d) and B(e, f, g, h), where A is
composed of a, b, c, and d, etc. Also suppose that a -> e.

Collapsing A is fine -- it yields A and B(e, f, g, h), with a link between A
and e.

Collapsing B is also fine -- it yields A and B, with a link between A and B.

Now, what happens if we uncollapse either of these compound nodes? If we
uncollapse B, it's fine -- B has the link from A to e stored already, so
uncollapsing B works without a problem. From there we can also uncollapse A.

However, if we uncollapse A before we uncollapse B, then we have a problem: A
has a link from a to e stored, but e currently does not exist. This system
will therefore cause an error.

What's the solution?

WELL, for one thing, we can filter outgoing/incoming edges much easier. Just:
// Unfiltered incoming/outgoing edges
uIncomingEdges = children.incomers('edge');
uOutgoingEdges = children.outgoers('edge');
// Correct incoming/outgoing edges -- will be move()'d with collapsing
incomingEdges = uIncomingEdges.difference(uOutgoingEdges);
outgoingEdges = uOutgoingEdges.difference(uIncomingEdges);
// Canonical incoming/outgoing edges -- these count as "removed" from the
// graph, but are used to represent the ideal connections btwn. nodes
// regardless of collapsing
cIncomingEdges = incomingEdges.clone();
cOutgoingEdges = outgoingEdges.clone();

This is a lot simpler, and then from here we can just operate on these without
bothering to worry about conditionals. We should really also just make a
single function for collapsing individual nodes, and then call that repeatedly
when collapsing everything at once.

OPTION TWO: 

ON RENDERING CLUSTERS
=====================
When we load clusters into the graph, we record their incoming/outgoing edges
(let's call them "_incomingEdges" and "_outgoingEdges") in the scratch data
for the cluster. We do this using the eleven lines of code above.
Previously, this work was done when collapsing, but doing it at rendering
should make things generally easier. FURTHERMORE, these edges represent the
"canonical" edges: due to collapsing different nodes at different times, we
may have to alter the source or destination of these edges, but these
references should always remain as the ideal representation of edges
connecting to the nodes within a cluster.
NOTE that, since some nodes are added before others, we may have to iterate
through all clusters after we've rendered everything. Perhaps make a fourth
function, initializeClusters(), which we'd call after the other three
render*() functions. That should work fine.

ON COLLAPSING INDIVIDUAL NODES
==============================
-When we collapse a compound node locally, we remove its children via
node.children().remove() or something like that. Normally, we'd just store
this entire result as the "removed elements" from collapsing this node --
however, this isn't satisfactory, since this includes exterior edges
(incoming/outgoing edges). So, we still call node.children.remove(), but we
store the result, "_interioreles" in the node's scratch data as the difference
of remove() and (_incoming U _outgoing).
-Next, for each incoming and outgoing edge of the compound node, we move the
edge -- with the currently-being-collapsed compound node as the source (for
outgoing edges) or as the sink (for incoming edges). This can be done fairly
painlessly using a call to edge.move(). If we detect that the
sink/source doesn't exist for a given exterior edge (i.e. the node to which
this edge is connected has already been collapsed), we connect the edge to
that node's parent instead.
NOTE that this is valid because THE ONLY WAY nodes can be
"removed" in this graph is through being collapsed: if some later feature
adds in the ability to remove nodes somehow, then we'll need to change this
to account for that possibility (like, checking if the node has a parent and
if that parent exists). But for now we're alright.

ON UNCOLLAPSING INDIVIDUAL NODES
================================
When we uncollapse a compound node locally, we would normally add back its
"removed elements," as discussed in the above section. However, since we're
not using that mechanism (since that includes exterior edges), we can
uncollapse nodes by:
-Add back "_interioreles". This does NOT add back any exterior edges yet.
-For each incoming and outgoing edge of the compound node, we check if
 the canonical source (for incoming edges) or sink (for outgoing edges) has
 been removed.
  --It should turn out that, regardless of whether or not the canonical
    exterior connection has been removed, using move() with a new source/target
    (source for outgoing nodes, target for incoming nodes) should account for
    the problem anyway. Woo!

END PROTOCOL FOR LOCAL COLLAPSING
=================================

This allows us to get the actual source/sink for each edge. Let's say, when we
load clusters, we also record their interior nodes and edges -- it should be
mutually exclusive with _exterioredges, for any elements connected to that
cluster in particular. So let's call this "_exterioredges" and "_interioreles".

When we collapse a node locally, we remove its interioreles (since the
cluster's nodes are contained within interioreles, this removes exterioredges
from the graph, also). 

When we collapse a node, we store its
"_interioreles". That is, we remove the element from the graph using
cy.remove() and store the result, then take the difference of the result with
_exterioredges to get _interioreles.

If any of the exterior edges connects to a node within another cluster, then
-- when we try to uncollapse

ONE POSSIBILITY: (Note, I didn't actually end up implementing this this way)

When we locally collapse a node, we currently store its child nodes and their
connected edges in a node.scratch() field (called "_removedchildren"). We also
store the edges added to connect directly to the collapsed node in another
node.scratch() field, called "_addededges".

Now, when we locally uncollapse a node, we should iterate through the list of
edges we're about to add back ("_removedchildren"). If the source/sink node on
any of those edges is not in the graph, then it must have been collapsed after
we collapsed this node. Therefore, what we can do here is remove the erroneous
edge and replace it with an edge to/from the compound node that contained the
old node. (cy.getElementById() works, even with removed nodes.) When we do
this, we need to do something special to ensure that as soon as the other node
is available, the correct edge is restored: we pass to the cy.scratch() of the
other compound node a new property, "_lostedges". (I made that up just now.)
"_lostedges" should be passed the a mapping, of the makeshift new edge TO the
removed erroneous edge.

When we uncollapse a node, we iterate through _lostedges and add all the
"values" (replaced edges) back, removing their corresponding makeshift edges
accordingly. This paradigm allows us to asymmetrically collapse/uncollapse
nodes, while guaranteeing that the graph will be as accurate as possible.
