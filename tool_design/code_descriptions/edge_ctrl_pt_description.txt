First, we extract the control points from the _draw_ attribute of edges in
xdot files.

Next, when we're rendering an edge in particular, we calculate for each of
its ctrl. pts. "p" the perpendicular distance from p to a line connecting the
source and sink nodes of the edge. There's a formula that can be used to do
this fairly simply. Now, for each control point, this perpendicular distance
-- let's call it D(p) -- can be used in control-point-distances.

Next, we calculate the distance from 


So, we use currEdge.ctrlPts to define the control points of this
edge for the unbundled bezier curve-style. Will have to use a
data mapping to get that to work -- define one property of the
edge in data called "ctrlpt-distances" and one called
"ctrlptweights", and each is just a string formatted to serve as
input to control-point-distances and control-point-weights,
respectively.
The control points are already converted to the new coordinate
system. So what I need to do is:
1. Determine the location of the source and sink node for this
edge. Since an edge could theoretically be declared "before" one
of the nodes it's connected to, I guess build up a dictionary
slash "mapping" of node IDs to the actual Node objects, just like
in the python script, and pass that mapping to this function.
When we're rendering things -- after the
entire file has been parsed -- we can use that dictionary to
identify the properties of the source/sink nodes (i.e.
coordinates), and from there we should be able to figure out the
equation for a straight line between those two points.
I guess for now we can just do node-position for edge-distances.
2. Once we've determined the line between the points, we can find
the distance between the two points by the equation
d = sqrt( (y2 - y1)^2 + (x2 - x1)^2 ).
3. Next, we can loop through the control point list that's an
attribute of the currEdge. For each control point located at
position (x0, y0), the perpendicular distance from the control
point to the line between the source and sink is given by the
equation
((y2 - y1)x0 + (x2-x1)y0 + x2y1 - y2x1)/d.
From there, we can append this perpendicular distance to a string
that will be used to represent control-point-distances.
Furthermore, we can ...I guess we can just do 1/x intervals for
each control point, where x = the number of control points? If
necessary we can do some more distance calculations to refine
this, but let's just stay simple for now and see where it goes.

