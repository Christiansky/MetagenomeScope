"use strict";

/* Takes as input a .xdot file (generated by Graphiz).
 * Right now we upload the file locally, but when we do this "for real"
 * we might want to consider these (and more, probably) options:
 *  -creating a html page for a specific xdot file (not sure how to go
 *   about this; should be somewhat similar to what Krona does)
 *  -parsing the xdot file in python and using that to generate javascript
 *   code that'll be used to serve up a new html page for a specific asm
 *   file???
 *  -Using a graph database as another type of input?
 * Using Cytoscape.js' batch controls, adds corresponding
 * nodes, edges, and clusters of nodes and edges to the
 * graph instance.
 */

// These sets of five points (in the format [[x1, y1], [x2, y2], ...])
// detail the polygons drawn to represent an invhouse (facing down; the
// shape of non-reverse-complement contigs) and a house (facing up; the
// shape of reverse-complement contigs).
// These points will be modified later to be rotated according to the
// graph's rotation.
const INVHOUSE_POLYPTS =
    [[-1, -1], [-1, 0.23587], [0, 1], [1, 0.23587], [1, -1]];
const HOUSE_POLYPTS =
    [[-1, 1], [-1, -0.23587], [0, -1], [1, -0.23587], [1, 1]];

// Regexes for detecting certain things in xdot.
const BOUNDBOX_REGEX = /bb=\"0,0,([\d\.e\+\-]+),([\d\.e\+\-]+)\"/;
const GRAPHROT_REGEX = /rotate=([\d\.e\+\-]+)/; // unused for now
const CLUSDECL_REGEX = /subgraph cluster_(\w+)\s{/;
const NODEDECL_REGEX = /(c?\d+)\s+\[/;
const EDGEDECL_REGEX = /(c?\d+):[nsew]\s+->\s+(c?\d+):[nsew]\s+\[/;
const NDEG_END_REGEX = /(.+)\];/; // works for both node/edge declarations

// Regexes for detecting node properties. Note that we're lazy with
// validating number formatting here -- since xdot files are generated by
// GraphViz, we can be (reasonably) sure the numbers within them will be
// vaid numbers, so we can be justifiably lax with our standards here.
const NODEHGHT_REGEX = /height=([\d\.e\+\-]+)/;
const NODEWDTH_REGEX = /width=([\d\.e\+\-]+)/;
const NODEPOS_REGEX = /pos=\"([\d\.e\+\-]+),([\d\.e\+\-]+)\"/;
const NODESHP_REGEX = /shape=(house|invhouse)/;

// Regexes for detecting the control points that describe the B-spline that
// GraphViz uses to represent an edge.
// Since long edges can have many control points, we define two regexes: 1
// for the first (and potentially only) line of control points, and 1 for
// the following lines of control points if they exist. (Note that GraphViz
// "splits" control point lines using backslashes.)
// We also define a regex specifying what the end of a _draw_ decl. in
// xdot looks like, so that we can easily detect where the list of control
// points ends (and so we can extract any pertinent data that was on that
// line, if necessary).
// NOTE that, as far as I can tell, _draw_ information for an edge will
// never be the last item in the [] list of properties for an edge in xdot.
// However, just to be safe, NDEG_END_REGEX does handle this scenario.
const ECTRLPTS_REGEX =
    /_draw_=\"c 7 -#[\dABCDEF]{6} B ([\de\+\-]+) ([\d\.e\+\-\s]*)/;
const ECTRLPTS_END_REGEX = /(.+)\",/;
const NEXTLINE_ECTRLPTS_REGEX = /([\d\.e\+\-\s]*)/;

// Approximate conversion factor from inches (the unit used by GraphViz for
// node width/height measurements) to pixels. TODO, we might want to
// consider node size more closely to see how accurate we can get it?
// Also -- maybe multiply coordinates by this, to get things worked out?
// 72 ppi?
const INCHES_TO_PIXELS = 54;

// Anything less than this constant will be considered a "straight" control
// point distance. Used for preventing the "badBezier" cytoscape.js bug, in
// which straight lines are considered "impossible" to draw.
// (I know, it sounds ridiculous to me.)
const CTRL_PT_DIST_EPSILON = 1.00;

// Misc. global variables we use to get certain functionality
var GRAPH_RENDERED = false;
// In degrees CCW from the default up->down direction
var PREV_ROTATION;
var CURR_ROTATION;
// A reference to the current SQL.Database object from which we obtain the
// graph's layout and biological data
var CURR_DB = null;
// Cytoscape.js graph instance
var cy = null;

if (!(window.File && window.FileReader)) {
	// TODO handle this better -- user should still be able to
	// play with sample assembly data
	// (or maybe support loading files some other non-HTML5 way?
	// something to look into)
	alert("Your browser does not support the HTML5 File APIs.");
}

// Initializes the Cytoscape.js graph instance.
// Takes as two arguments the polygon-point strings used for non-RC nodes
// (invhousePolygonPts) and for RC nodes (housePolygonPts).
function initGraph() {
    cy = cytoscape({
        container: document.getElementById("cy"),
        layout: {
            // We parse GraphViz' generated xdot files to copy the layout
            // provided by GraphViz. To manually specify node positions, we
            // use the "preset" Cytoscape.js layout.
            name: 'preset'
        },
        // NOTE setting these off for now
        //minZoom: 0.01,
        //maxZoom: 15,
        pixelRatio: 1.0, // improves performance on high-density displays
        //hideEdgesOnViewport: false, // = true might help optimize a bit 
        style: [
            {
                selector: 'node',
                style: {
                    label: 'data(id)',
                    // rendering text is computationally expensive, so if
                    // we're zoomed out so much that the text would be
                    // illegible (or hard-to-read, at least) then don't
                    // render the text.
                    'min-zoomed-font-size': 12,
                    width: 'data(w)',
                    height: 'data(h)'
                }
            },
            // Following four classes are used to set properties of
            // compound nodes (analogous to clusters in GraphViz) 
            {
                selector: 'node.cluster',
                style: {
                    'background-opacity': 0.65,
                    'shape': 'square'
                }
            },
            {
                selector: 'node.R',
                style: {
                    // matches 'green2' in graphviz
                    // (but honestly I just picked what I considered to be
                    // the least visually offensive shade of green)
                    'background-color':'#00EE00',
                }
            },
            {
                selector: 'node.B',
                style: {
                    // matches 'cornflowerblue' in graphviz
                    'background-color':'#6495ED'
                }
            },
            {
                selector: 'node.C',
                style: {
                    // matches 'salmon' in graphviz
                    'background-color':'#FA8072'
                }
            },
            {
                selector: 'node.Y',
                style: {
                    // matches 'darkgoldenrod1' in graphviz
                    'background-color':'#FFB90F'
                }
            },
            {
                selector: 'node.noncluster',
                style: {
                    shape: 'polygon',
                    'shape-polygon-points': 'data(polypts)'
                }
            },
            {
                selector: 'edge',
                style: {
                    'target-arrow-shape':'triangle'
                }
            },
            {
                // Used for edges that were assigned valid (i.e. not
                // just a straight line or self-directed edge)
                // cpd/cpw properties from the xdot file.
                // As is discussed a number of times throughout this file
                // (and in an external document -- see
                // cytoscape_unbundledbeziernodes_report.md), using
                // unbundled-bezier curves causes a number of odd bugs in
                // Cytoscape.js. Hence why some things might seem strange.
                selector: 'edge.unbundledbezier',
                style: {
                    'curve-style': 'unbundled-bezier',
                    'control-point-distances': 'data(cpd)',
                    'control-point-weights': 'data(cpw)',
                    'edge-distances': 'node-position'
                }
            },
            {
                // Used for:
                //  -Self-directed edges
                //  -Lines that are determined upon parsing the xdot file to
                //   be sufficiently close to a straight line
                //  -Temporary edges, for which we have no control point
                //   data (i.e. any edges directly from/to compound nodes
                //   during the collapsing process)
                selector: 'edge.basicbezier',
                style: {
                    'curve-style': 'bezier'
                }
            }
        ]
    });
}

/* Given a cluster, either collapses it (if already uncollapsed) or
 * uncollapses it (if already collapsed).
 */
function toggleCluster(cluster) {
    cy.startBatch();
    if (cluster.data("isCollapsed")) {
        uncollapseCluster(cluster);
    }
    else {
        collapseCluster(cluster);
    }
    cy.endBatch();
}

/* Collapses a given single cluster, making use of the
 * cluster's actual and canonical exterior edge data.
 * 
 * NOTE that this can result in the presence of codirected edges, if a
 * single node connects to multiple edges within the cluster (e.g. a
 * node has two outgoing edges, to both starting nodes of a frayed rope).
 */
function collapseCluster(cluster, moveMap) {
    var children = cluster.children();
    // For each edge with a target in the compound node...
    for (var incomingEdgeID in cluster.data("incomingEdgeMap")) {
        var oldEdge = cy.getElementById(incomingEdgeID);
        oldEdge.removeClass("unbundledbezier");
        oldEdge.addClass("basicbezier");
        oldEdge.move({target: cluster.id()});
    }
    // For each edge with a source in the compound node...
    for (var outgoingEdgeID in cluster.data("outgoingEdgeMap")) {
        var oldEdge = cy.getElementById(outgoingEdgeID);
        oldEdge.removeClass("unbundledbezier");
        oldEdge.addClass("basicbezier");
        oldEdge.move({source: cluster.id()});
    }
    // Update local flag for collapsed status (useful for local toggling)
    cluster.data("isCollapsed", true);
    // Update list of locally collapsed nodes (useful for global toggling)
    cy.scratch("_collapsed", cy.scratch("_collapsed").union(cluster));
    cy.scratch("_uncollapsed", cy.scratch("_uncollapsed").difference(cluster));
    if (cy.scratch("_uncollapsed").empty()) {
        if ($("#collapseButton").button("option", "label")[0] === 'C') {
            changeButtonText("collapseButton", "Uncollapse All Node Groups");
            changeButtonIcon("collapseButton", "ui-icon-plus");
        }
    }
    cluster.data("interiorEles").remove();
}

/* Uncollapses a given single cluster, making use of the cluster's actual
 * and canonical exterior edge data.
 */
function uncollapseCluster(cluster) {
    // Restore child nodes + interior edges
    cluster.data("interiorEles").restore();
    // "Reset" edges to their original target/source within the cluster
    for (var incomingEdgeID in cluster.data("incomingEdgeMap")) {
        var newTgt = cluster.data("incomingEdgeMap")[incomingEdgeID][1];
        var oldEdge = cy.getElementById(incomingEdgeID);
        // If the edge isn't connected to another cluster, and the edge
        // wasn't a basicbezier to start off with (i.e. it has control point
        // data), then change its classes to update its style.
        if (!oldEdge.source().hasClass("cluster") && oldEdge.data("cpd")) {
            oldEdge.removeClass("basicbezier");
            oldEdge.addClass("unbundledbezier");
        }
        oldEdge.move({target: newTgt});
    }
    for (var outgoingEdgeID in cluster.data("outgoingEdgeMap")) {
        var newSrc = cluster.data("outgoingEdgeMap")[outgoingEdgeID][0];
        var oldEdge = cy.getElementById(outgoingEdgeID);
        if (!oldEdge.target().hasClass("cluster") && oldEdge.data("cpd")) {
            oldEdge.removeClass("basicbezier");
            oldEdge.addClass("unbundledbezier");
        }
        oldEdge.move({source: newSrc});
    }
    // Update local flag for collapsed status (useful for local toggling)
    cluster.data("isCollapsed", false);
    // Update list of locally collapsed nodes (useful for global toggling)
    cy.scratch("_collapsed", cy.scratch("_collapsed").difference(cluster));
    cy.scratch("_uncollapsed", cy.scratch("_uncollapsed").union(cluster));
    if (cy.scratch("_collapsed").empty()) {
        if ($("#collapseButton").button("option", "label")[0] === 'U') {
            changeButtonText("collapseButton", "Collapse All Node Groups");
            changeButtonIcon("collapseButton", "ui-icon-minus");
        }
    }
}

// Sets bindings for certain objects in the graph.
function setGraphBindings() {
    // Enable right-clicking to collapse/uncollapse compound nodes
    // We store added edges + removed nodes/edges in element-level
    // data, to facilitate only doing the work of determining which
    // elements to remove/etc. once (the first time around)
    cy.on('cxttap', 'node',
        function(e) {
            var node = e.cyTarget;
            if (node.hasClass("cluster")) {
                toggleCluster(node);
            }
        }
    );
    // I can't believe this actually works -- "this is too convenient
    // to actually work the first time I try it"...
    // This fixes all bad (invalid, so invisible) edges as soon as the
    // graph is first rendered, and then calls cy.offRender() to disable
    // the check for future rendering frames.
    // This ensures we call fixBadEdges() only after edges have been
    // displayed.
    cy.onRender(function() {
        fixBadEdges();
        cy.offRender();
    });
    // NOTE this binding works -- when dragging a node, if any of its edges
    // become invalid then this automatically switches them to basicbezier
    // edges. It works great on smaller graphs, but on huge graphs it can
    // make dragging nodes painfully slow.
    // We can optimize this a bit by caching the node incomer/
    // outgoer lists (see initNodeAdjacents()), but we'd have to keep
    // those updated through collapsing.
    // And even with cached lists, this is pretty slow. I guess we could
    // somehow reduce the granularity of this (e.g. only register something
    // every other frame?), though? But then we'd want to keep this
    // reliable, also.
    // Also, this removes edges' control point info, meaning once an edge
    // has been modified to a basicbezier it stays that way until the graph
    // is reloaded. Not sure if there's a way to check if the edge is valid
    // (and change it back to an unbundledbezier) without using the
    // Cytoscape.js renderer, so this would only make sense for graphs we
    // want to generally have as static.
    // (Maybe make this an option for the user?) TODO get this faster
    //cy.on('drag', 'node',
    //    function(e) {
    //        var node = e.cyTarget;
    //        fixBadEdges(node.data("adjacentEdges"));
    //    }
    //);
    // TODO look into getting this more efficient in the future, if possible
    // (Renders labels only on tapping elements; doesn't really save that
    // much time, and might actually be less efficient due to the time taken
    // to register a tap event)
    //cy.on('tapstart', 'node',
    //    function(e) {
    //        var node = e.cyTarget;
    //        console.log(node);
    //        cy.style().selector("[id = '" + node.id() + "']").style({
    //            'label': 'data(id)'
    //        }).update();
    //    }
    //);
}

/* Rotates a node's position and, if applicable, its polygon definition.
 * NOTE that position of a compound node only seems to matter when that
 * compound node is collapsed -- as soon as that compound node regains
 * one or more of its children, its position is neglected again.
 */
function rotateNode(i, n) {
    // Rotate node position
    var oldPt = n.position();
    var newPt = rotateCoordinate(oldPt['x'], oldPt['y']);
    n.position({x: newPt[0], y: newPt[1]});
    // Rotate node polygon definition
    if (n.hasClass("noncluster")) { 
        var coordList = n.data('polypts').trim().split(" ");
        var clLen = coordList.length;
        var pointList = [];
        var currPoint = [];
        for (var i = 0; i < clLen; i++) {
            if (i % 2 === 0) {
                // i/2 is always an integer, since i is even
                pointList[i / 2] =
                    [parseFloat(coordList[i]), parseFloat(coordList[i + 1])];
            }
        }
        n.data('polypts', rotateCoordinatesToStr(pointList));
    }
}

/* Modifies the graph's nodes and compound nodes "in situ" to move their
 * positions, along with rotating the control points of edges and the
 * definition of the house/invhouse node polygons.
 */
function changeRotation() {
    PREV_ROTATION = CURR_ROTATION;
    CURR_ROTATION = parseInt(document.getElementById("rotation").value);
    if (GRAPH_RENDERED || !$("#fitButton").button("option", "disabled")) {
        updateStatus("Rotating graph...");
        window.setTimeout(function() {
            cy.startBatch();
            // This only rotates nodes that are not collapsed
            cy.filter('node').each(rotateNode);
            // Rotate nodes within currently collapsed node groups
            cy.scratch("_collapsed").each(function(i, n) {
                n.data("interiorNodes").each(rotateNode);
            });
            cy.endBatch();
            cy.fit();
            updateStatus("Finished rotating graph.");
        }, 10);
    }
}

// Changes the label text of the given button ID.
function changeButtonText(buttonId, newText) {
    $("#" + buttonId).button("option", "label", newText);
}

// Changes the primary icon of the given button ID.
function changeButtonIcon(buttonId, newIcon) {
    $("#" + buttonId).button("option", {icons: {primary: newIcon}});
}

// Clears the graph, to facilitate drawing another one.
// Assumes a graph has already been drawn (i.e. cy !== null)
function destroyGraph() {
    cy.destroy();
    changeButtonText("collapseButton", "Collapse All Node Groups");
    changeButtonIcon("collapseButton", "ui-icon-minus");
    GRAPH_RENDERED = false;
}

/* Asynchronously loads the contents of the specified local file into
 * memory. After the file has been loaded, calls parsexdot() with the
 * file's contents. The ideal thing would be to parse the file
 * line-by-line, but we can look into that later.
 */
function loadgraphfile() {
    var xdotText = [];
    var fr = new FileReader();
    // For xdot parsing --
    // Okay, so the ideal thing here would be to read this in line-by-line,
	// so we don't use an excessive amount of memory for large xdot files.
	var inputfile = document.getElementById('fileselector').files[0];
    if (inputfile === undefined) {
        alert("Please select an .xdot or .db file to display.");
        return;
    }
    else if (inputfile.name.endsWith(".xdot")) {
        fr.onload = function(e) {
            if (e.target.readyState === FileReader.DONE) {
                document.title = inputfile.name;
                xdotText = e.target.result.split('\n');
                updateStatus("Parsing xdot...");
                window.setTimeout(function() { parsexdot(xdotText) }, 10);
            }
        }
	    fr.readAsText(inputfile);
    }
    else if (inputfile.name.endsWith(".db")) {
        fr.onload = function(e) {
            if (e.target.readyState === FileReader.DONE) {
                var uIntArr = new Uint8Array(e.target.result);
                CURR_DB = new SQL.Database(uIntArr);
                parseDBcomponents();
            }
        }
        fr.readAsArrayBuffer(inputfile);
        return;
    }
    else {
        alert("Please select a valid .db or .xdot file to display.");
        return;
    }
}

/* Retrieves assembly-wide and component information from the database,
 * adjusting UI elements to prepare for component drawing accordingly.
 */
function parseDBcomponents() {
    // Get assembly-wide info from the graph
    var stmt = CURR_DB.prepare("SELECT * FROM assembly;");
    stmt.step();
    var graphInfo = stmt.getAsObject();
    document.title = graphInfo["filename"];
    var contigInfo = graphInfo["contig_count"].toLocaleString();
    var bpInfo = graphInfo["total_length"].toLocaleString() + " bp";
    var edgeInfo = graphInfo["edge_count"].toLocaleString();
    var compCt = graphInfo["component_count"];
    var compInfo = compCt.toLocaleString();
    var n50Info = graphInfo["n50"].toLocaleString() + " bp";
    // Adjust UI elements
    $("#filenameEntry").text(graphInfo["filename"]); 
    $("#filetypeEntry").text(graphInfo["filetype"]);
    $("#contigCtEntry").text(contigInfo); 
    $("#totalBPLengthEntry").text(bpInfo); 
    $("#edgeCountEntry").text(edgeInfo);
    $("#connCmpCtEntry").text(compInfo);
    $("#n50Entry").text(n50Info);
    $("#componentselector").spinner("option", "max", compCt);
    $("#componentselector").spinner("enable");
    $("#infoButton").button("enable");
    $("#drawButton").button("enable");
}

/* Draws the selected connected component in the .db file -- its nodes, its
 * edges, its clusters -- to the screen.
 */
function drawComponent() {
    var cmpRank = $("#componentselector").spinner("value");
    if (!(Number.isInteger(cmpRank) && cmpRank >= 1
        && cmpRank <= $("#componentselector").spinner("option", "max"))) {
        alert("Please enter a valid component rank using the input field.");
        return;
    }
    // Okay, we can draw this component!
    // Graph initialization stuff here (shamelessly taken from initGraph()
    // below -- I'm thinking we can just get rid of that when we're done
    // with this)
    if (cy !== null) {
        // If we already have a graph instance, clear that graph before
        // initializing another one
        destroyGraph();
    }
    initGraph();
    setGraphBindings();
    PREV_ROTATION = 0;
    CURR_ROTATION = parseInt(document.getElementById("rotation").value);
    cy.scratch("_collapsed", cy.collection());
    cy.scratch("_uncollapsed", cy.collection());
    cy.scratch("_ele2parent", {});
    // Now we render the nodes, edges, and clusters of this component.
    // But first we need to get the bounding box of this component.
    var bbStmt = CURR_DB.prepare(
        "SELECT boundingbox_x, boundingbox_y FROM components WHERE " +
        "size_rank = ?", [cmpRank]);
    bbStmt.step();
    var bb = bbStmt.getAsObject();
    // We need a fast way to associate node IDs with their x/y positions.
    // This is for calculating edge control point weight/distance.
    // And doing 2 DB queries (src + tgt) for each edge will take a lot of
    // time -- O(2|E|) time, specifically, with the only benefit of not
    // taking up a lot of space. So we go with the mapping solution -- it's
    // not particularly pretty, but it works alright.
    var node2pos = {};
    cy.startBatch();
    var clustersStmt = CURR_DB.prepare(
        "SELECT * FROM clusters WHERE component_rank = ?", [cmpRank]);
    while (clustersStmt.step()) {
        renderClusterObject(clustersStmt.getAsObject());
    }
    var nodesStmt = CURR_DB.prepare(
        "SELECT * FROM contigs WHERE component_rank = ?", [cmpRank]);
    var currNode;
    while (nodesStmt.step()) {
        currNode = nodesStmt.getAsObject();
        renderNodeObject(currNode, bb);
        // TODO inefficiency -- only call gv2cyPoint once. We call it once
        // in renderNodeObject() and once here. To rectify, call after
        // init'ing currNode and then pass to renderNodeObject().
        node2pos[currNode['id']] = gv2cyPoint(
            currNode['x'], currNode['y'],
            [bb['boundingbox_x'], bb['boundingbox_y']]
        );
    }
    var edgesStmt = CURR_DB.prepare(
        "SELECT * FROM edges WHERE component_rank = ?", [cmpRank]);
    while (edgesStmt.step()) {
        renderEdgeObject(edgesStmt.getAsObject(), node2pos, bb);
    }
    // NOTE modified initClusters() to do cluster height after the fact.
    // This represents an efficiency when parsing xdot files, although it
    // shouldn't really affect anything major.
    initClusters();
    cy.endBatch();
    cy.fit();
    $("#searchButton").button("enable");
    $("#fitButton").button("enable");
    $("#collapseButton").button("enable");
}

// TODO verify that this doesn't mess stuff up when you back out of and then
// return to the page. Also are memory leaks even a thing that we have
// to worry about in Javascript?????????
function closeDB() {
    if (CURR_DB !== null) {
        CURR_DB.close();
    }
}

/* Pops up a dialog displaying assembly information. */
function displayInfo() {
    $("#infoDialog").dialog("open");
}

/* Fits the graph to all its nodes. This should be useful if the user
 * somehow gets lost while navigating the graph (particularly for really
 * large graphs).
 */
function fitGraph() {
    updateStatus("Fitting graph...");
    window.setTimeout(
        function() {
            cy.fit();
            updateStatus("Finished fitting graph.");
        }, 10
    );
}

// Displays the search dialog
function showSearchDialog() {
    $("#searchDialog").dialog("open");
}

function disableTooltip() {
    $(document).tooltip("disable");
}

function enableTooltip() {
    $(document).tooltip("enable");
}

// Simple shortcut used to enable searching by pressing Enter (charCode 13)
function searchWithEnter(e) {
    if (e.charCode === 13) {
        searchForNode();
    }
}

// Updates the "status" div with a message. When done before long
// operations, the long operation in question should usually be performed
// as a callback from window.setTimeout (so the div can be updated before).
function updateStatus(message) {
    document.getElementById("status").innerHTML = message;
}

// Centers the graph on a given node (edges/clusters can also be specified,
// using Node1->Node2 or [B/R/C]Node1_Node2_Node3... syntax respectively.)
function searchForNode() {
    var nodes =
        document.getElementById('nodeselector').value.split(",");
    var nodeEles = cy.collection(); // empty collection (for now)
    var newEle;
    var parentID;
    for (var c = 0; c < nodes.length; c++) {
        newEle = cy.getElementById(nodes[c].trim());
        if (newEle.empty()) {
            // Check if this element is in the graph (but currently
            // collapsed, and therefore inaccessible) or if it just
            // never existed in the first place
            parentID = cy.scratch("_ele2parent")[nodes[c].trim()];
            if (parentID !== undefined) {
                // We've collapsed the parent of this element, so identify
                // its parent instead
                nodeEles = nodeEles.union(cy.getElementById(parentID));
            }
            else {
                // It's a bogus element
                alert("Error -- element ID " + nodes[c].trim() +
                      " is not in this component.");
                return;
            }
        }
        else {
            // Identify the node in question
            nodeEles = nodeEles.union(newEle);
        }
    }
    // Fit the graph to the identified nodes.
    cy.fit(nodeEles);
    // Unselect all previously-selected nodes
    // (TODO: is this O(n)? because if so, it's not worth it, probably)
    // (Look into this)
    cy.filter(':selected').unselect();
    // Select all identified nodes, so they can be dragged if desired
    // (and also to highlight them).
    nodeEles.select();
}

/* Determines whether collapsing or uncollapsing should be performed,
 * updates the status div accordingly, and begins the (un)collasping
 * process.
 */
function startCollapseAll() {
    var currVal = $("#collapseButton").button("option", "label");
    if (currVal[0] === 'U') {
        updateStatus("Uncollapsing...");
    }
    else {
        updateStatus("Collapsing...");
    }
    window.setTimeout(function() { collapseAll(currVal[0]) }, 50);
}

/* Collapse/uncollapse all compound nodes in the graph.
 * This just delegates to collapseCluster() and uncollapseCluster().
 * An argument of 'U' uncollapses all nodes, and an argument of 'C' (or
 * anything that isn't 'U') collapses all nodes.
 */
function collapseAll(operationCharacter) { 
    cy.startBatch();
    if (operationCharacter === 'U') {
        changeButtonText("collapseButton", "Collapse All Node Groups");
        changeButtonIcon("collapseButton", "ui-icon-minus");
        cy.scratch("_collapsed").each(
            function(i, cluster) {
                uncollapseCluster(cluster);
            }
        );
        updateStatus("Finished uncollapsing.");
    }
    else {
        changeButtonText("collapseButton", "Uncollapse All Node Groups");
        changeButtonIcon("collapseButton", "ui-icon-plus");
        cy.scratch("_uncollapsed").each(
            function(i, cluster) {
                collapseCluster(cluster);
            }
        );
        updateStatus("Finished collapsing.");
    }
    cy.endBatch();
}

/* Simple classes (well, not really classes, but they're basically as
 * close as you can get in Javascript?) defining attributes of
 * nodes/edges/clusters.
 */
function Node(id, x, y, width, height, shape) {
    this.id = id;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.shape = shape; // can be either "house" or "invhouse"
}

function Edge(sourceID, sinkID) {
    this.sourceID = sourceID;
    this.sinkID = sinkID;
    // We use a -> in the edge ID instead of just concatenating the
    // source and sink IDs. I was originally just concatenating the
    // IDs, but that actually caused a problem when I had an edge
    // between nodes "c3" and "9" -- it made the edge's ID "c39",
    // conflicting with the actual node with the ID "c39"!
    // I'm pretty sure - and > are illegal characters for GraphViz
    // node IDs, so this should be safe.
    // NOTE for future reference: the error message I got in the
    // dev. console said Cytoscape.js couldn't add another
    // "element" with the ID "c39". Turns out "element" can mean
    // either node or edge...
    this.id = this.sourceID + "->" + this.sinkID;
    this.ctrlPts = [];
    // Number of control points this edge has; obtained directly from xdot
    // file's information (defined in _draw_ as B n, where n is the number
    // of control points)
    // Useful for testing, I guess.
    this.ctrlPtNum = 0;    
    // String used as intermediate format to store ctrl points
    this.ctrlPtStr = "";
}

function Cluster(id, nodes, edges) {
    this.id = id;
    this.nodes = nodes;
    this.edges = edges;
}

// Converts an angle in degrees to radians (for use with Javascript's trig
// functions)
function degreesToRadians(angle) {
    return angle * (Math.PI / 180);
}

// Rotates a coordinate by a given clockwise angle (in degrees).
// Returns an array of [x', y'] representing the new point.
function rotateCoordinate(xCoord, yCoord) {
    // NOTE The formula for a coordinate transformation here works for all
    // degree inputs of rotation. However, to save time, we just check
    // to see if the rotation is a factor of 360 (i.e. the rotated
    // point would be the same as the initial point), and if so we just
    // return the original coordinates.
    var rotation = PREV_ROTATION - CURR_ROTATION;
    if (rotation % 360 === 0) {
        return [xCoord, yCoord];
    }
    else {
        var newX = (xCoord * Math.cos(degreesToRadians(rotation)))
                    - (yCoord * Math.sin(degreesToRadians(rotation)));
        var newY = (yCoord * Math.cos(degreesToRadians(rotation)))
                    + (xCoord * Math.sin(degreesToRadians(rotation)));
        newX = parseFloat(newX.toFixed(2));
        newY = parseFloat(newY.toFixed(2));
        return [newX, newY];
    }
}

// Used for angles not divisible by 90 degrees. Technically this is used for
// 180, 270, etc, but those are due to rounding errors (only an
// infinitesimal part of the polygon is lost, so it doesn't really count)
function boundCoordinate(coord, lowerBound, upperBound) {
    if (coord >= lowerBound) {
        if (coord <= upperBound) {
            return coord;
        }
        else {
            return upperBound;
        }
    }
    else {
        return lowerBound;
    }
}

/* Given an array of [x, y] coordinates (e.g. [[0, 0], [-1, 1], [0.5, 0]]),
 * rotates each coordinate about the axis by the specified
 * rotation angle (in degrees), returning a Cytoscape.js-acceptable string
 * of the points in the format "x1 y1 x2 y2"..."xn yn".
 */
function rotateCoordinatesToStr(coordinateList) {
    var outputString = "";
    var currCoord, rotatedCoord;
    var newX, newY;
    for (var c = 0; c < coordinateList.length; c++) {
        currCoord = coordinateList[c];
        rotatedCoord = rotateCoordinate(currCoord[0], currCoord[1]);
        outputString += boundCoordinate(rotatedCoord[0], -1, 1) + " ";
        outputString += boundCoordinate(rotatedCoord[1], -1, 1) + " ";
    }
    return outputString.trim();
}

/* Given the bounding box of the graph, a graph rotation angle (in degrees),
 * and a point specified by x and y coordinates, converts the point from
 * GraphViz' coordinate system to Cytoscape.js' coordinate system, rotating
 * the point if necessary (i.e. the rotation angle mod 360 !== 0).
 *
 * For reference -- GraphViz uses the standard Cartesian system in which
 * the bottom-left corner of the screen is the origin, (0, 0). Cytoscape.js
 * inverts the y-axis, with the origin (0, 0) being situated at the
 * top-right corner of the screen. So to transform a point (x, y) from
 * GraphViz to Cytoscape.js, you just return (x, y'), where
 * y' = the vertical length of the bounding box, minus y.
 * (The x-coordinate remains the same.)
 *
 * This is a purposely simple function -- in the event that we decide to
 * use another graphing library/layout system/etc. for some reason, we can
 * just modify this function accordingly.
 */
function gv2cyPoint(xCoord, yCoord, boundingbox) {
    // Convert from GraphViz to Cytoscape.js
    var cyY = boundingbox[1] - yCoord;
    var cyX = xCoord;
    // Rotate the point about the axis if necessary
    return rotateCoordinate(cyX, cyY);
}

/* Converts a string of control points (defined in the form "x1 y1 x2 y2",
 * for an arbitrary number of points) to a 2-dimensional list of floats,
 * of the form [[x1, y1], [x2, y2], ...]. If the input string contains an
 * odd number of coordinate components for some reason (e.g.
 * "x1 y1 x2 y2 x3") then this will return null, since that's invalid.
 * This also takes care of converting each point in the input string from
 * GraphViz' coordinate system to Cytoscape.js' coordinate system.
 * (Hence why the graph's bounding box and rotation are parameters here.)
 */
function ctrlPtStrToList(ctrlPointStr, boundingbox) {
    // Create coordList, where every coordinate is an element (e.g.
    // [x1, y1, x2, y2, ...]
    var coordList = ctrlPointStr.trim().split(" ");
    // Merge two elements of coordList at a time. NOTE that this is only
    // possible when coordList.length is even, so this is why we have to
    // wait until we're finished parsing all control points until doing
    // this conversion. (If coordList.length is odd, return null --
    // something went very wrong in that case.)
    var clLen = coordList.length;
    if (clLen % 2 !== 0) {
        return null;
    }
    else {
        var pointList = [];
        var currPoint = [];
        for (var i = 0; i < clLen; i++) {
            if (i % 2 === 0) {
                // i/2 is always an integer, since i is even
                pointList[i / 2] = gv2cyPoint(
                        parseFloat(coordList[i]),
                        parseFloat(coordList[i + 1]),
                        boundingbox
                );
            }
        }
        return pointList;
    }
}

/* Checks to see if a line of text contains a property that can be added to
 * a given node. If so, adds that property to the node.
 * This takes care of converting node position points to the new coordinate
 * system -- hence why the graph's bounding box and rotation are parameters.
 */
function attemptAddNodeAttr(textLine, currNode, boundingbox) {
    var h_match = NODEHGHT_REGEX.exec(textLine);
    var w_match = NODEWDTH_REGEX.exec(textLine);
    var p_match = NODEPOS_REGEX.exec(textLine);
    var s_match = NODESHP_REGEX.exec(textLine);
    if (h_match !== null) {
        currNode.height = parseFloat(h_match[1]) * INCHES_TO_PIXELS;
    }
    else if (w_match !== null) {
        currNode.width = parseFloat(w_match[1]) * INCHES_TO_PIXELS;
    }
    else if (p_match !== null) {
        var xCoord = parseFloat(p_match[1]);
        var yCoord = parseFloat(p_match[2]);
        var convertedPt =
            gv2cyPoint(xCoord, yCoord, boundingbox);
        currNode.x = convertedPt[0];
        currNode.y = convertedPt[1];
    }
    else if (s_match !== null) {
        currNode.shape = s_match[1];
    }
}

// Alerts user with an error message and updates status accordingly.
function xdotParsingError(errorMsg) {
    alert(errorMsg);
    updateStatus("Halted xdot parsing due to error.");
}

// A common error needed in xdot parsing
function boundingboxError() {
    xdotParsingError("Error: no bounding box specified in xdot file.");
}

/* Parses the xdot file, in the format as an array of strings.
 * NOTE that this assumes that the xdot file is properly formatted.
 * Specifically, it uses xdotversion=1.7 as a guideline.
 * This also assumes that each statement is on its own line, i.e.
 * declarations of two clusters would look like
 * subgraph cluster_XYZ {
 *  ... lines detailing things here ...
 * }
 * subgraph cluster_ABC {
 *  ...
 * }
 * Note that each ending curly brace is on its own line.
 * (The ideal thing here would be to actually write a proper parser that
 * would decompose the input into a list of tokens agnostic to spacing and
 * formatting and then parse that, but this is a bit simpler/easier to do.
 * Since we're guaranteed that GraphViz (or at least xdot version 1.7) will
 * produce output formatted to the specifications here, we can just parse
 * this lazily line-by-line.)
 */
function parsexdot(fileLines) {
    // Misc. useful variables
    var lineCount = fileLines.length;
    var currLine;
    var id = "";              // tmp ID string
    var tmp_results = [];     // tmp array for regex results
    var boundingbox = null;   // Top-right corner of the graph in GraphViz
    var allClusters = [];     // List of all clusters in the graph
    var standaloneNodes = []; // List of all nodes not in clusters
    var standaloneEdges = []; // List of all edges not in clusters
    var nodeMapping = {};     // Mapping of node IDs to node objects
    // Used to catch information on same line as the end of a declaration
    // that would otherwise be discarded due to us parsing line-by-line.
    var lastInfo = ""; 
    
    // Variables for when we're parsing a cluster. We maintain the name of
    // the cluster in addition to all its current edges and nodes.
    var parsingCluster = false;
    var currCluster = null;

    // Variables for when we're parsing a node.
    var parsingNode = false;
    var currNode = null;

    // Variables for when we're parsing an edge.
    var parsingEdge = false;
    var parsingCtrlPts = false; // is true iff parsingEdge is true
    var currEdge = null;
    var edgeNodeMatches = [];
    var ctrlPtMatches = [];
    var endCtrlPointMatches = [];

    // Reset these things
    PREV_ROTATION = 0;
    CURR_ROTATION = parseInt(document.getElementById("rotation").value);

    // Iterate line-by-line through the file, identifying cluster, node,
    // and edge declarations and declaration closings as we go along.
    for (var line = 0; line < lineCount; line++) {
        // remove leading/trailing whitespace
        currLine = fileLines[line].trim();

        if (BOUNDBOX_REGEX.exec(currLine) !== null && !parsingCluster) {
            // We detected the bounding box of the entire graph. Bounding
            // boxes are only declared for graphs and subgraphs (clusters),
            // so if we're not already parsing a cluster we can assume this
            // is the bounding box giving the entire graph's dimensions.
            //
            // (NOTE that "bounding box" is a bit of a misnomer. Since
            // GraphViz always (at least, for our purposes) sets the origin
            // at (0, 0) in the bottom-left corner of the graph, we only
            // bother recording information about the other point
            // indicating the bounding box' dimensions: the graph's
            // top-right corner.)
            //
            // (And we don't even really use the x data of that point,
            // since the y-dimension is the only changed property between
            // GraphViz' and Cytoscape.js' coordinate systems. Oh well.)
            tmp_results = BOUNDBOX_REGEX.exec(currLine);
            boundingbox = [
                parseFloat(tmp_results[1]),
                parseFloat(tmp_results[2])
            ];
        }
        else if (CLUSDECL_REGEX.exec(currLine) !== null) {
            // We're parsing a cluster
            parsingCluster = true;
            id = CLUSDECL_REGEX.exec(currLine)[1];
            currCluster = new Cluster(id, [], []);
        }
        else if (currLine.indexOf('}') > -1 && parsingCluster) {
            // We just finished parsing a cluster
            parsingCluster = false;
            allClusters.push(currCluster);
        }
        else if (NODEDECL_REGEX.exec(currLine) !== null) {
            // We found a node declaration!
            // NOTE -- yeah, exec'ing the regexes twice here is bad
            // practice, I know. Will figure out something better (TODO)..
            if (boundingbox === null) {
                boundingboxError();
                return;
            }
            parsingNode = true;
            id = NODEDECL_REGEX.exec(currLine)[1];
            currNode = new Node(id, -1, -1, -1, -1);
            attemptAddNodeAttr(currLine, currNode, boundingbox);
        }
        else if (EDGEDECL_REGEX.exec(currLine) !== null) {
            // We found an edge declaration!
            parsingEdge = true;
            edgeNodeMatches = EDGEDECL_REGEX.exec(currLine);
            currEdge = new Edge(edgeNodeMatches[1], edgeNodeMatches[2]);
            ctrlPtMatches = ECTRLPTS_REGEX.exec(currLine);
            if (ctrlPtMatches !== null) {
                parsingCtrlPts = true;
                currEdge.ctrlPtNum = parseInt(ctrlPtMatches[1]);
                currEdge.ctrlPtStr = ctrlPtMatches[2].trim() + " ";
            }
            endCtrlPointMatches = ECTRLPTS_END_REGEX.exec(currLine);
            if (ECTRLPTS_END_REGEX.exec(currLine) !== null) {
                // if the ctrl. point declaration is only one-line long,
                // don't try to parse multiple lines of it
                parsingCtrlPts = false;
            }
        }
        else if (NDEG_END_REGEX.exec(currLine) !== null) {
            lastInfo = NDEG_END_REGEX.exec(currLine)[1];
            if (parsingNode) {
                if (boundingbox === null) {
                    boundingboxError();
                    return;
                }
                attemptAddNodeAttr(lastInfo, currNode, boundingbox);
                // Save current node's info, either to cluster node list or
                // to a list of "standalone" nodes
                if (parsingCluster) {
                    currCluster.nodes.push(currNode);
                }
                else {
                    standaloneNodes.push(currNode);
                }
                nodeMapping[currNode.id] = currNode;
                parsingNode = false;
                currNode = null;
            }
            else if (parsingEdge) {
                // Save current edge's info. Same general concept as above.
                if (parsingCtrlPts) {
                    // I don't think this should ever happen (from what I
                    // can tell, _draw_ is always the first attribute of an
                    // edge in xdot), but I tested this and it does work --
                    // if _draw_ is the last attribute, then we still
                    // detect all of it using lastInfo. Cool.
                    lastInfo = lastInfo.trim().replace("\"", "");
                    currEdge.ctrlPtStr += lastInfo;
                    parsingCtrlPts = false;
                }
                if (boundingbox === null) {
                    boundingboxError();
                    return;
                }
                currEdge.ctrlPts = ctrlPtStrToList(currEdge.ctrlPtStr,
                        boundingbox);
                if (currEdge.ctrlPts === null) {
                    xdotParsingError(
                        "Odd number of coordinates given for a "
                        + "control point of edge " + currEdge.id
                    );
                    return;
                }
                else if (currEdge.ctrlPts.length !== currEdge.ctrlPtNum) {
                    xdotParsingError(
                        "Invalid number of control points given for edge "
                        + currEdge.id
                    );
                    return;
                }
                if (parsingCluster) {
                    currCluster.edges.push(currEdge);
                }
                else {
                    standaloneEdges.push(currEdge);
                }
                parsingEdge = false;
                currEdge = null;
            }
            // Note that the ]; delimiter is also used for ending the graph
            // property declaration in clusters. Since we don't record
            // cluster attributes (we can infer it from their name +
            // children easily), this isn't a problem, though.
        }
        else if (parsingNode) {
            if (boundingbox === null) {
                boundingboxError();
                return;
            }
            attemptAddNodeAttr(currLine, currNode, boundingbox);
        }
        else if (parsingEdge) {
            if (parsingCtrlPts) {
                tmp_results = ECTRLPTS_END_REGEX.exec(currLine);
                if (tmp_results === null) {
                    tmp_results = NEXTLINE_ECTRLPTS_REGEX.exec(currLine);
                    if (tmp_results === null) {
                        xdotParsingError(
                            "Invalid xdot edge stmt.: " + currEdge.id
                        );
                        return;
                    }
                    else {
                        currEdge.ctrlPtStr += tmp_results[1].trim() + " ";
                    }
                }
                else {
                    currEdge.ctrlPtStr += tmp_results[1].trim() + " ";
                    parsingCtrlPts = false;
                }
            }
        }
    }
    updateStatus("Rendering graph...");
    window.setTimeout(function() {
        renderGraph(allClusters, standaloneNodes,
                standaloneEdges, nodeMapping);
    }, 10);
}

// Renders the graph, calling the other render*() functions as needed
function renderGraph(allClusters, standaloneNodes, standaloneEdges,
        nodeMapping) {
    if (cy !== null) {
        // If we already have a graph instance, clear that graph before
        // initializing another one
        destroyGraph();
    }
    // Actually create the graph instance (cy)
    initGraph();
    setGraphBindings();
    // Render clusters, nodes, and edges (done in batch)
    cy.startBatch();
    renderClusters(allClusters, nodeMapping);
    renderNodes(standaloneNodes, null);
    renderEdges(standaloneEdges, nodeMapping);
    initClusters();
    // NOTE disabling this for now; reenable if we decide to implement
    // dynamic edge checking upon nodes being dragged
    //initNodeAdjacents();
    cy.endBatch();
    // Run a few post-processing tasks on the graph
    cy.fit();
    GRAPH_RENDERED = true;
    updateStatus("Finished rendering.");
}

// Identifies invalid (per Cytoscape.js) edges and converts them to basic
// bezier edges that can be properly rendered.
// If provided, will only check edgeList.
function fixBadEdges(edgeList) {
    cy.batch(
        function() {
            if (edgeList === undefined) {
                cy.filter('edge.unbundledbezier').each(fixSingleEdge);
            }
            else {
                edgeList.each(fixSingleEdge);
            }
        }
    );
}

/* If the given edge is a badBezier or badLine, converts it to a basicbezier
 * NOTE that this class should be called from within a batch operation, to
 * prevent style class collisions.
 */
function fixSingleEdge(i, e) {
    if (e._private.rscratch['badBezier'] ||
            e._private.rscratch['badLine']) {
        e.removeClass('unbundledbezier');
        e.removeData('cpd');
        e.removeData('cpw');
        e.addClass('basicbezier');
    }
}

/* Initializes the adjacent edges (i.e. incoming + outgoing edges) of
 * every non-cluster node in the graph. This would be useful if we
 * enabled dynamic edge validity checking (it makes checking each node's
 * edges more efficient, since we only have to build up these collections
 * once), but for now dynamic edge validity checking is disabled due to
 * still being too slow.
 * So we don't really use this function for anything, but it could probably
 * be useful in the future?
 */
function initNodeAdjacents() {
    cy.filter('node.noncluster').each(
        function(i, node) {
            node.data("adjacentEdges",
                node.incomers('edge').union(node.outgoers('edge'))
            );
        }
    );
}

// Records actual and canonical incoming/outgoing edges of clusters in the
// data of the cluster, as incomingEdges and outgoingEdges (actual
// edges in the graph) and cSource and cTarget (canonical source/target).
// This is going to involve iterating over every compound node in the graph.
// See collapse() for guidance on how to do that, I guess.
// NOTE that we delay doing this work until after everything else has been
// rendered in order to ensure that all edges/nodes necessary for this have
// already been rendered.
function initClusters() {
    // For each compound node...
    cy.scratch("_uncollapsed").each(
        function(i, node) {
            var children = node.children();        
            // Unfiltered incoming/outgoing edges
            var uIncomingEdges = children.incomers('edge');
            var uOutgoingEdges = children.outgoers('edge');
            // Actual incoming/outgoing edges -- will be move()'d as
            // this cluster/adjacent cluster(s) are collapsed/uncollapsed
            var incomingEdges  = uIncomingEdges.difference(uOutgoingEdges);
            var outgoingEdges  = uOutgoingEdges.difference(uIncomingEdges);
            // Mapping of edge ID to [cSource, cTarget]
            // Used since move() removes references to edges, so storing IDs
            // is more permanent
            var incomingEdgeMap = {};
            var outgoingEdgeMap = {};
            // "Canonical" incoming/outgoing edge properties -- these
            // are used to represent the ideal connections
            // between nodes regardless of collapsing
            incomingEdges.each(
                function(j, edge) {
                    incomingEdgeMap[edge.id()] =
                        [edge.source().id(), edge.target().id()];
                }
            );
            outgoingEdges.each(
                function(j, edge) {
                    outgoingEdgeMap[edge.id()] =
                        [edge.source().id(), edge.target().id()];
                }
            );
            // Get the "interior elements" of the cluster: all child nodes,
            // plus the edges connecting child nodes within the cluster
            // This considers cyclic edges (e.g. the edge connecting a
            // cycle's "end" and "start" nodes) as "interior elements,"
            // which makes sense as they don't connect the cycle's children
            //  to any elements outside the cycle.
            var interiorEdges = children.connectedEdges().difference(
                incomingEdges).difference(outgoingEdges);
            var wid = 0;
            var hgt = 0;
            children.each(function(i,e) {
                wid += Math.pow(100,
                        Math.pow(e.data("w") / INCHES_TO_PIXELS, 2)
                );
                hgt += Math.pow(100,
                        Math.pow(e.data("h") / INCHES_TO_PIXELS, 2)
                );
            });
            wid = INCHES_TO_PIXELS * Math.sqrt(Math.log(wid) / Math.log(100));
            hgt = INCHES_TO_PIXELS * Math.sqrt(Math.log(hgt) / Math.log(100));
            // Record incoming/outgoing edges in this
            // cluster's data. Will be useful during collapsing.
            // We also record "interiorNodes" -- having a reference to just
            // these nodes saves us the time of filtering nodes out of
            // interiorEles when rotating collapsed node groups.
            node.data({
                "incomingEdgeMap": incomingEdgeMap,
                "outgoingEdgeMap": outgoingEdgeMap,
                "interiorEles"   : interiorEdges.union(children),
                "interiorNodes"  : children,
                "w"              : wid,
                "h"              : hgt
            });
        }
    );
}

// Renders a list of clusters in the graph. Takes a mapping of Node IDs to
// Node objects, to be passed along to renderEdges().
function renderClusters(clusterList, nodeMapping) {
    var currCluster;
    var currChild;
    var n;
    var wid, hgt;
    // Record all compound nodes (clusters) in two mutually exclusive
    // collections, which we update as we collapse/uncollapse clusters.
    // (See collapsing_protocol.txt for more information.)
    cy.scratch("_collapsed", cy.collection());
    cy.scratch("_uncollapsed", cy.collection());
    cy.scratch("_ele2parent", {});
    for (var c = 0; c < clusterList.length; c++) {
        currCluster = clusterList[c];
        // Calculate cluster dimensions as sum of children nodes' original
        // sizes. Since the sum of logs is really multiplication, we raise
        // the width and height of each child to 2 (since we scale nodes by
        // area), and then we raise 100 to that (since we took the log in
        // base 100 of the original width/height of the node).
        // We do these separately, since we can't guarantee that
        // width/height of each node will be the same (it should be up to
        // the user). 
        // NOTE that width/height of a cluster are only used when the
        // cluster is collapsed; when a cluster has children nodes, it just
        // scales to contain its children.
        // Convert back using logs, and then add that up, then log that
        // back. Area should be proportional to log of size.
        for (n = 0, wid = 0, hgt = 0; n < currCluster.nodes.length; n++) {
            currChild = currCluster.nodes[n];
            wid += Math.pow(100,
                    Math.pow(currChild.width / INCHES_TO_PIXELS, 2)
            );
            hgt += Math.pow(100,
                    Math.pow(currChild.height / INCHES_TO_PIXELS, 2)
            );
        }
        wid = INCHES_TO_PIXELS * Math.sqrt(Math.log(wid) / Math.log(100));
        hgt = INCHES_TO_PIXELS * Math.sqrt(Math.log(hgt) / Math.log(100));
        // Add this compound node to the list of uncollapsed compound nodes
        cy.scratch("_uncollapsed", cy.scratch("_uncollapsed").union(
            cy.add({
                classes: currCluster.id[0] + ' cluster',
                data: {id: currCluster.id, w: wid, h: hgt, isCollapsed: false}
            })
        ));
        renderNodes(currCluster.nodes, currCluster.id);
        renderEdges(currCluster.edges, nodeMapping, currCluster.id);
    }
}

// Renders a given node object, obtained by getAsObject() from running a
// query on CURR_DB for selecting rows from table contigs.
function renderNodeObject(nodeObj, boundingboxObject) {
    // TODO find a way to only do this once per render job -- no need to
    // recalc it n times, that's just stupid
    if (nodeObj['shape'] === 'house') {
        var nodePolygonPts = rotateCoordinatesToStr(HOUSE_POLYPTS);
    }
    else {
        var nodePolygonPts = rotateCoordinatesToStr(INVHOUSE_POLYPTS);
    }
    var pos = gv2cyPoint(nodeObj['x'], nodeObj['y'],
        [boundingboxObject['boundingbox_x'],
         boundingboxObject['boundingbox_y']]);
    var nodeID = nodeObj['id'];
    // NOTE that NULL in sqlite gets translated to Javascript as null, which
    // works perfectly for our use of the node parent field.
    // Hence why we can just use the parent_cluster_id field directly.
    var parentID = nodeObj['parent_cluster_id'];
    cy.add({
        classes: 'noncluster',
        data: {id: nodeID, parent: parentID, polypts: nodePolygonPts, 
               w: INCHES_TO_PIXELS * nodeObj['w'],
               h: INCHES_TO_PIXELS * nodeObj['h'],
               house: nodeObj['shape'] === 'house'},
        position: {x: pos[0], y: pos[1]}
    });
    if (parentID !== null) {
        cy.scratch("_ele2parent")[nodeID] = parentID;
    }
}

// Renders a cluster object.
function renderClusterObject(clusterObj) {
    var clusterID = clusterObj["cluster_id"];
    cy.scratch("_uncollapsed", cy.scratch("_uncollapsed").union(
        cy.add({
            classes: clusterID[0] + ' cluster',
            data: {id: clusterID, w: 5, h: 5, isCollapsed: false}
        })
    ));
}

// Renders edge object. Hopefully in a not-terrible way.
// Uses node2pos (mapping of node object from DB -> [x, y] position)
// to calcluate relative control point weight stuff.
function renderEdgeObject(edgeObj, node2pos, boundingboxObject) {
    var sourceID = edgeObj['source_id'];
    var targetID = edgeObj['target_id'];
    var edgeID = sourceID + "->" + targetID;
    if (edgeObj['parent_cluster_id'] !== null) {
        cy.scratch("_ele2parent")[edgeID] = edgeObj['parent_cluster_id'];
    }
    if (sourceID === targetID) {
        // It's a self-directed edge; don't bother parsing ctrl pt
        // info, just render it as a bezier edge and be done with it
        cy.add({
            classes: "basicbezier",
            data: {id: edgeID, source: sourceID, target: targetID}
        });
        return;
    }
    var srcPos = node2pos[sourceID];
    var tgtPos = node2pos[targetID];
    var srcSinkDist = distance(srcPos, tgtPos);
    var ctrlPts = ctrlPtStrToList(edgeObj['control_point_string'],
            [boundingboxObject['boundingbox_x'],
             boundingboxObject['boundingbox_y']]);
    var ctrlPtLen = edgeObj['control_point_count'];
    var nonzero = false;
    var ctrlPtDists = "";
    var ctrlPtWeights = "";
    var currPt, dsp, dtp, w, ws, wt, nonzero;
    for (var p = 0; p < ctrlPtLen; p++) {
        currPt = ctrlPts[p];
        // TODO inefficiency here -- rework pointToLineDistance.
        var d = -pointToLineDistance(currPt,
            {x: srcPos[0], y: srcPos[1]}, {x: tgtPos[0], y: tgtPos[1]});
        dsp = distance(currPt, srcPos);
        dtp = distance(currPt, tgtPos);
        // By the pythagorean thm., the interior of the square root
        // below should always be positive -- the hypotenuse must
        // always be greater than both of the other sides of a right
        // triangle.
        // However, due to Javascript's lovely (...)
        // type system, rounding errors can cause the hypotenuse (dsp
        // or dtp)
        // be represented as slightly less than d. So, to account for
        // these cases, we just take the abs. value of the sqrt body.
        // NOTE that ws = distance on line to source;
        //           wt = distance on line to target
        ws = Math.sqrt(Math.abs(Math.pow(dsp, 2) - Math.pow(d, 2)));
        wt = Math.sqrt(Math.abs(Math.pow(dtp, 2) - Math.pow(d, 2)));
        // Get the weight of the control point on the line between
        // source and sink oriented properly -- if the control point is
        // "behind" the source node, we make it negative, and if the
        // point is "past" the sink node, we make it > 1. Everything in
        // between the source and sink falls within [0, 1] inclusive.
        if (wt > srcSinkDist && wt > ws) {
            // The ctrl. pt. is "behind" the source node
            w = -ws / srcSinkDist;
        }
        else {
            // The ctrl. pt. is anywhere past the source node
            w = ws / srcSinkDist;
        }
        // If we detect all of the control points of an edge are less
        // than some epsilon value, we just render the edge as a normal
        // bezier (which defaults to a straight line).
        if (Math.abs(d) > CTRL_PT_DIST_EPSILON) {
            nonzero = true;
        }
        // Control points with a weight of 0 (as the first ctrl pt)
        // or a weight of 1 (as the last ctrl pt) aren't valid due
        // to implicit points already "existing there."
        // (See https://github.com/cytoscape/cytoscape.js/issues/1451)
        // This preemptively rectifies such control points.
        if (p === 0 && w === 0.0) {
            w = 0.01;
        }
        else if (p === (ctrlPtLen - 1) && w === 1.0) {
            w = 0.99;
        }
        ctrlPtDists += d.toFixed(2) + " ";
        ctrlPtWeights += w.toFixed(2) + " ";
    }
    ctrlPtDists = ctrlPtDists.trim();
    ctrlPtWeights = ctrlPtWeights.trim();
    if (nonzero) {
        // The control points should (hopefully) be valid
        cy.add({
            classes: "unbundledbezier",
            data: {id: edgeID, source: sourceID,
                   target: targetID, cpd: ctrlPtDists,
                   cpw: ctrlPtWeights}
        });
    }
    else {
        // The control point distances are small enough that
        // we can just represent this as a straight bezier curve
      cy.add({
          classes: "basicbezier",
          data: {id: edgeID, source: sourceID, target: targetID}
      });
    }
}

// Renders a list of nodes in the graph.
// If parentID is passed as anything that isn't null, it will be used as
// the parent ID for all nodes in the list. If parentID is null, then no
// parent will be given.
function renderNodes(nodeList, parentID) { 
    var currNode;
    var nodePolygonPts;
    var isHouse;
    for (var nodeIndex = 0; nodeIndex < nodeList.length; nodeIndex++) {
        currNode = nodeList[nodeIndex]; 
        if (currNode.shape === 'house') {
            nodePolygonPts = rotateCoordinatesToStr(HOUSE_POLYPTS);
            isHouse = true;
        }
        else {
            nodePolygonPts = rotateCoordinatesToStr(INVHOUSE_POLYPTS);
            isHouse = false;
        }
        if (parentID !== null) {
            cy.add({
                classes: 'noncluster',
                data: {id: currNode.id, parent: parentID,
                       w: currNode.width, h: currNode.height,
                       polypts: nodePolygonPts, house: isHouse},
                position: {x: currNode.x, y: currNode.y}
            });
            cy.scratch("_ele2parent")[currNode.id] = parentID;
        }
        else {
            cy.add({
                classes: 'noncluster',
                data: {id: currNode.id, w: currNode.width,
                       h: currNode.height, polypts: nodePolygonPts,
                       house: isHouse},
                position: {x: currNode.x, y: currNode.y}
            });
        }
    }
}

/* Given two points, each in the form [x, y], returns the distance between
 * the points obtained using d = sqrt((x2 - x1)^2 + (y2 - y1)^2).
 * e.g. distance([1, 2], [3, 4]) = sqrt((3 - 1)^2 + (4 - 2)^2) = sqrt(8)
 */
function distance(point1, point2) {
    return Math.sqrt(
              Math.pow(point2[0] - point1[0], 2)
            + Math.pow(point2[1] - point1[1], 2)
    );
}

/* Given a line that passes through two Nodes -- lNode1 and lNode2
 * -- this function returns the perpendicular distance from a point to the
 * line.
 */
function pointToLineDistance(point, lNode1, lNode2) {
    var lDist = distance([lNode1.x, lNode1.y], [lNode2.x, lNode2.y]);
    if (lDist === 0) {
        return 0;
    }
    var ydelta = lNode2.y - lNode1.y;
    var xdelta = lNode2.x - lNode1.x;
    var consts = (lNode2.x * lNode1.y) - (lNode2.y * lNode1.x);
    var numer = (ydelta * point[0]) - (xdelta * point[1]) + consts;
    return numer / lDist;
}

// Renders a list of edges in the graph.
// Takes as an argument a mapping of Node IDs to Node objects.
// Also takes a parent ID, if you want these edges to be searchable when
// collapsed (searching for a collapsed element will show its parent).
// The parent ID argument is optional.
function renderEdges(edgeList, nodeMapping, parentID) {
    var currEdge;
    var sourceNode, sinkNode;
    var srcSinkDist;
    var ctrlPtLen;
    var p, d, dsp, dtp, ws, wt, w;
    var currPt;
    var nonzero;
    // Used when generating input for unbundled bezier edges
    var ctrlPtDists = "";
    var ctrlPtWeights = "";
    for (var edgeIndex = 0; edgeIndex < edgeList.length; edgeIndex++) {
        currEdge = edgeList[edgeIndex];
        // Save edge-parent relationship, if specified (see above comment)
        if (parentID !== undefined) {
            cy.scratch("_ele2parent")[currEdge.id] = parentID;
        }
        if (currEdge.sourceID === currEdge.sinkID) {
            // It's a self-directed edge; don't bother parsing ctrl pt
            // info, just render it as a bezier edge and be done with it
            // (We can't really calculate relative control points
            // effectively, since there isn't really a "line" from source to
            // sink that exists for self-directed edges).
            cy.add({
                classes: "basicbezier",
                data: {id: currEdge.id, source: currEdge.sourceID,
                target: currEdge.sinkID}
            });
            continue;
        }
        sourceNode = nodeMapping[currEdge.sourceID];
        sinkNode = nodeMapping[currEdge.sinkID];
        srcSinkDist = distance([sourceNode.x, sourceNode.y],
                               [sinkNode.x, sinkNode.y]);
        ctrlPtLen = currEdge.ctrlPts.length;
        nonzero = false;
        ctrlPtDists = "";
        ctrlPtWeights = "";
        for (p = 0; p < ctrlPtLen; p++) {
            currPt = currEdge.ctrlPts[p];
            // Alright, being perfectly honest here, I have no idea why
            // negating the perpendicular distance works in this case. It
            // just sort of... works for some reason. TODO figure it out.
            d = -pointToLineDistance(currPt, sourceNode, sinkNode);
            dsp = distance(currPt, [sourceNode.x, sourceNode.y]);
            dtp = distance(currPt, [sinkNode.x, sinkNode.y]);
            // By the pythagorean thm., the interior of the square root
            // below should always be positive -- the hypotenuse must
            // always be greater than both of the other sides of a right
            // triangle.
            // However, due to Javascript's lovely (...)
            // type system, rounding errors can cause the hypotenuse (dsp
            // or dtp)
            // be represented as slightly less than d. So, to account for
            // these cases, we just take the abs. value of the sqrt body.
            // NOTE that ws = distance on line to source;
            //           wt = distance on line to target
            ws = Math.sqrt(Math.abs(Math.pow(dsp, 2) - Math.pow(d, 2)));
            wt = Math.sqrt(Math.abs(Math.pow(dtp, 2) - Math.pow(d, 2)));
            // Get the weight of the control point on the line between
            // source and sink oriented properly -- if the control point is
            // "behind" the source node, we make it negative, and if the
            // point is "past" the sink node, we make it > 1. Everything in
            // between the source and sink falls within [0, 1] inclusive.
            if (wt > srcSinkDist && wt > ws) {
                // The ctrl. pt. is "behind" the source node
                w = -ws / srcSinkDist;
            }
            else {
                // The ctrl. pt. is anywhere past the source node
                w = ws / srcSinkDist;
            }
            // If we detect all of the control points of an edge are less
            // than some epsilon value, we just render the edge as a normal
            // bezier (which defaults to a straight line).
            if (Math.abs(d) > CTRL_PT_DIST_EPSILON) {
                nonzero = true;
            }
            // Control points with a weight of 0 (as the first ctrl pt)
            // or a weight of 1 (as the last ctrl pt) aren't valid due
            // to implicit points already "existing there."
            // (See https://github.com/cytoscape/cytoscape.js/issues/1451)
            // This preemptively rectifies such control points.
            if (p === 0 && w === 0.0) {
                w = 0.01;
            }
            else if (p === (ctrlPtLen - 1) && w === 1.0) {
                w = 0.99;
            }
            ctrlPtDists += d.toFixed(2) + " ";
            ctrlPtWeights += w.toFixed(2) + " ";
        }
        ctrlPtDists = ctrlPtDists.trim();
        ctrlPtWeights = ctrlPtWeights.trim();
        if (nonzero) {
            // The control points should (hopefully) be valid
            cy.add({
                classes: "unbundledbezier",
                data: {id: currEdge.id, source: currEdge.sourceID,
                       target: currEdge.sinkID, cpd: ctrlPtDists,
                       cpw: ctrlPtWeights}
            });
        }
        else {
            // The control point distances are small enough that
            // we can just represent this as a straight bezier curve
            cy.add({
                classes: "basicbezier",
                data: {id: currEdge.id, source: currEdge.sourceID,
                       target: currEdge.sinkID}
            });
        }
    }
}
