"use strict";

/* Takes as input a .db file (generated by collate.py).
 * Using Cytoscape.js' batch controls, adds corresponding
 * nodes, edges, and clusters of nodes and edges to the
 * graph instance.
 */

// How often (e.g. after how many nodes/half-edges) we update the progress
// bar with its new value. Higher values of this mean less timeouts, which
// means the graph is loaded somewhat faster, while smaller values of this
// mean more timeouts (slower loading) but choppier progress bar progress.
// Might be a good idea to scale this relative to the total # of nodes/edges
// in the graph, but worrying about that later
const PROGRESS_BAR_UPDATE_FREQ = 3;

// These sets of five points (in the format [[x1, y1], [x2, y2], ...])
// detail the polygons drawn to represent an invhouse (facing down; the
// shape of non-reverse-complement nodes) and a house (facing up; the
// shape of reverse-complement nodes).
// These points will be modified later to be rotated according to the
// graph's rotation.
const INVHOUSE_POLYPTS =
    [[-1, -1], [-1, 0.23587], [0, 1], [1, 0.23587], [1, -1]];
const HOUSE_POLYPTS =
    [[-1, 1], [-1, -0.23587], [0, -1], [1, -0.23587], [1, 1]];

// Approximate conversion factor from inches (the unit used by GraphViz for
// node width/height measurements) to pixels. TODO, we might want to
// consider node size more closely to see how accurate we can get it?
// Also -- maybe multiply coordinates by this, to get things worked out?
// 72 ppi?
const INCHES_TO_PIXELS = 54;

// Anything less than this constant will be considered a "straight" control
// point distance. Used for preventing the "badBezier" cytoscape.js bug, in
// which straight lines are considered "impossible" to draw.
// (I know, it sounds ridiculous to me.)
const CTRL_PT_DIST_EPSILON = 1.00;

// Misc. global variables we use to get certain functionality
// In degrees CCW from the default up->down direction
var PREV_ROTATION;
var CURR_ROTATION;
// A reference to the current SQL.Database object from which we obtain the
// graph's layout and biological data
var CURR_DB = null;
// Total number of nodes and edges in the current asm graph
var ASM_NODE_COUNT = 0;
var ASM_EDGE_COUNT = 0;
var CURR_NE = 0;
var TOTAL_NE = 0;
// Cytoscape.js graph instance
var cy = null;
// Number of non-cluster nodes / edges currently selected.
var SELECTED_ELE_COUNT = 0;
var SELECTED_ELES = null;
// Array of node IDs which the user requested info on. Used as "input"
// for the DNA dialog.
var NODES_TO_QUERY = [];
var EDGE_TABLE_HEADER = "<tr><th colspan='3'>Selected Edge Information</th></tr><tr><th>Source ID</th><th>Target ID</th><th>Multiplicity</th></tr>";
var NODE_TABLE_HEADER = "<tr><th colspan='4'>Selected Node Information</th></tr><tr><th>ID</th><th>Length</th><th>Depth</th><th>G/C Content</th></tr>";
var CLUSTER_TABLE_HEADER = "<tr><th colspan='3'>Selected Cluster Information</th></tr><tr><th>ID</th><th>Type</th><th>Child Count</th></tr>";

if (!(window.File && window.FileReader)) {
	// TODO handle this better -- user should still be able to
	// play with demo assembly data, if available?
	alert("Your browser does not support the HTML5 File APIs.");
}

// Initializes the Cytoscape.js graph instance.
// Takes as two arguments the polygon-point strings used for non-RC nodes
// (invhousePolygonPts) and for RC nodes (housePolygonPts).
function initGraph() {
    cy = cytoscape({
        container: document.getElementById("cy"),
        layout: {
            // We parse GraphViz' generated xdot files to copy the layout
            // provided by GraphViz. To manually specify node positions, we
            // use the "preset" Cytoscape.js layout.
            name: 'preset'
        },
        // NOTE setting these off for now
        //minZoom: 0.01,
        //maxZoom: 15,
        pixelRatio: 1.0, // improves performance on high-density displays
        hideEdgesOnViewport: true, // improves performance
        //textureOnViewport: true, // improves performance (but kind of ugly)
        userPanningEnabled: false,
        userZoomingEnabled: false,
        boxSelectionEnabled: false,
        autounselectify: true,
        autoungrabify: true,
        style: [
            {
                selector: 'node',
                style: {
                    label: 'data(id)',
                    // rendering text is computationally expensive, so if
                    // we're zoomed out so much that the text would be
                    // illegible (or hard-to-read, at least) then don't
                    // render the text.
                    'min-zoomed-font-size': 12,
                    width: 'data(w)',
                    height: 'data(h)'
                }
            },
            // Following five classes are used to set properties of
            // compound nodes (analogous to clusters in GraphViz) 
            {
                selector: 'node.cluster',
                style: {
                    'background-opacity': 0.65,
                    'shape': 'square',
                    'compound-sizing-wrt-labels': 'exclude',
                    'padding-top': 0,
                    'padding-right': 0,
                    'padding-left': 0,
                    'padding-bottom': 0,
                    'text-valign': 'bottom'
                }
            },
            {
                selector: 'node.R',
                style: {
                    // matches 'green2' in graphviz
                    // (but honestly I just picked what I considered to be
                    // the least visually offensive shade of green)
                    'background-color':'#00EE00',
                }
            },
            {
                selector: 'node.B',
                style: {
                    // matches 'cornflowerblue' in graphviz
                    'background-color':'#6495ED'
                }
            },
            {
                selector: 'node.C',
                style: {
                    // matches 'salmon' in graphviz
                    'background-color':'#FA8072'
                }
            },
            {
                selector: 'node.Y',
                style: {
                    // matches 'darkgoldenrod1' in graphviz
                    'background-color':'#FFB90F'
                }
            },
            {
                selector: 'node.noncluster',
                style: {
                    shape: 'polygon',
                    'shape-polygon-points': 'data(polypts)',
                    'background-color': 'data(bg_color)'
                }
            },
            // Oddly enough, this doesn't seem to impact performance in
            // component 1 of the Shakya assembly. It seems
            // that the selection style stuff still happens here (?),
            // regardless of the settings.
            //{
            //    selector: ':active',
            //    style: {
            //        'overlay-opacity': 0
            //    }
            //},
            {
                selector: 'node.noncluster:selected',
                style: {
                    // NOTE I liked using a border for indicating selected
                    // nodes, but it interfered with unbundled-bezier edges
                    // occasionally. So we just darken selected nodes instead.
                    //'border-color': '#000',
                    //'border-opacity': 1,
                    //'border-width': 5
                    'background-blacken': 0.5
                }
            },
            {
                selector: 'edge:selected',
                style: {
                    'line-color': '#000',
                    'source-arrow-color': '#000',
                    'target-arrow-color': '#000',
                    'mid-source-arrow-color': '#000',
                    'mid-target-arrow-color': '#000'
                }
            },
            {
                selector: 'node.cluster:selected',
                style: {
                    'border-width': 5,
                    'border-color': '#000'
                }
            },
            {
                selector: 'edge',
                style: {
                    'target-arrow-shape': 'triangle',
                    'width': 'data(thickness)'
                }
            },
            {
                // Used for edges that were assigned valid (i.e. not
                // just a straight line or self-directed edge)
                // cpd/cpw properties from the xdot file.
                // As is discussed a number of times throughout this file
                // (and in an external document -- see
                // cytoscape_unbundledbeziernodes_report.md), using
                // unbundled-bezier curves causes a number of odd bugs in
                // Cytoscape.js. Hence why some things might seem strange.
                selector: 'edge.unbundledbezier',
                style: {
                    'curve-style': 'unbundled-bezier',
                    'control-point-distances': 'data(cpd)',
                    'control-point-weights': 'data(cpw)',
                    'edge-distances': 'node-position'
                }
            },
            {
                // Used for:
                //  -Self-directed edges
                //  -Lines that are determined upon parsing the xdot file to
                //   be sufficiently close to a straight line
                //  -Temporary edges, for which we have no control point
                //   data (i.e. any edges directly from/to compound nodes
                //   during the collapsing process)
                selector: 'edge.basicbezier',
                style: {
                    'curve-style': 'bezier'
                }
            }
        ]
    });
}

/* Given a cluster, either collapses it (if already uncollapsed) or
 * uncollapses it (if already collapsed).
 */
function toggleCluster(cluster) {
    cy.startBatch();
    if (cluster.data("isCollapsed")) {
        uncollapseCluster(cluster);
    }
    else {
        collapseCluster(cluster);
    }
    cy.endBatch();
}

/* Collapses a given single cluster, making use of the
 * cluster's actual and canonical exterior edge data.
 * 
 * NOTE that this can result in the presence of codirected edges, if a
 * single node connects to multiple edges within the cluster (e.g. a
 * node has two outgoing edges, to both starting nodes of a frayed rope).
 */
function collapseCluster(cluster, moveMap) {
    var children = cluster.children();
    // For each edge with a target in the compound node...
    for (var incomingEdgeID in cluster.data("incomingEdgeMap")) {
        var oldEdge = cy.getElementById(incomingEdgeID);
        oldEdge.removeClass("unbundledbezier");
        oldEdge.addClass("basicbezier");
        oldEdge.move({target: cluster.id()});
    }
    // For each edge with a source in the compound node...
    for (var outgoingEdgeID in cluster.data("outgoingEdgeMap")) {
        var oldEdge = cy.getElementById(outgoingEdgeID);
        oldEdge.removeClass("unbundledbezier");
        oldEdge.addClass("basicbezier");
        oldEdge.move({source: cluster.id()});
    }
    // Update local flag for collapsed status (useful for local toggling)
    cluster.data("isCollapsed", true);
    // Update list of locally collapsed nodes (useful for global toggling)
    cy.scratch("_collapsed", cy.scratch("_collapsed").union(cluster));
    cy.scratch("_uncollapsed", cy.scratch("_uncollapsed").difference(cluster));
    if (cy.scratch("_uncollapsed").empty()) {
        if ($("#collapseButton").button("option", "label")[0] === 'C') {
            changeCollapseButton(true);
        }
    }
    cluster.scratch("_interiorEles").remove();
}

/* Uncollapses a given single cluster, making use of the cluster's actual
 * and canonical exterior edge data.
 */
function uncollapseCluster(cluster) {
    // Restore child nodes + interior edges
    cluster.scratch("_interiorEles").restore();
    // "Reset" edges to their original target/source within the cluster
    for (var incomingEdgeID in cluster.data("incomingEdgeMap")) {
        var newTgt = cluster.data("incomingEdgeMap")[incomingEdgeID][1];
        var oldEdge = cy.getElementById(incomingEdgeID);
        // If the edge isn't connected to another cluster, and the edge
        // wasn't a basicbezier to start off with (i.e. it has control point
        // data), then change its classes to update its style.
        if (!oldEdge.source().hasClass("cluster") && oldEdge.data("cpd")) {
            oldEdge.removeClass("basicbezier");
            oldEdge.addClass("unbundledbezier");
        }
        oldEdge.move({target: newTgt});
    }
    for (var outgoingEdgeID in cluster.data("outgoingEdgeMap")) {
        var newSrc = cluster.data("outgoingEdgeMap")[outgoingEdgeID][0];
        var oldEdge = cy.getElementById(outgoingEdgeID);
        if (!oldEdge.target().hasClass("cluster") && oldEdge.data("cpd")) {
            oldEdge.removeClass("basicbezier");
            oldEdge.addClass("unbundledbezier");
        }
        oldEdge.move({source: newSrc});
    }
    // Update local flag for collapsed status (useful for local toggling)
    cluster.data("isCollapsed", false);
    // Update list of locally collapsed nodes (useful for global toggling)
    cy.scratch("_collapsed", cy.scratch("_collapsed").difference(cluster));
    cy.scratch("_uncollapsed", cy.scratch("_uncollapsed").union(cluster));
    if (cy.scratch("_collapsed").empty()) {
        if ($("#collapseButton").button("option", "label")[0] === 'U') {
            changeCollapseButton(false);
        }
    }
}

// Sets bindings for certain objects in the graph.
function setGraphBindings() {
    // Enable right-clicking to collapse/uncollapse compound nodes
    // We store added edges + removed nodes/edges in element-level
    // data, to facilitate only doing the work of determining which
    // elements to remove/etc. once (the first time around)
    cy.on('cxttap', 'node',
        function(e) {
            // Prevent collapsing being done during iterative drawing
            if (!$("#fitButton").button("option", "disabled")) {
                var node = e.cyTarget;
                if (node.hasClass("cluster")) {
                    toggleCluster(node);
                }
            }
        }
    );
    // I can't believe this actually works -- "this is too convenient
    // to actually work the first time I try it"...
    // This fixes all bad (invalid, so invisible) edges as soon as the
    // graph is first rendered, and then calls cy.offRender() to disable
    // the check for future rendering frames.
    // This ensures we call fixBadEdges() only after edges have been
    // displayed.
    // UPDATE: It looks like adding in the progress bar stuff, likely due to
    // use of timeouts, messes this up and prevents it from being run (?).
    // Or maybe fixBadEdges() is just run too soon? Anyway, moving
    // fixBadEdges() to after we call cy.fit() seems to work fine. So I'm
    // just going to do that.
    //cy.onRender(function() {
    //    fixBadEdges();
    //    cy.offRender();
    //});
    // TODO define 3 distinct events for selection for node.noncluster,
    // edge, and node.cluster, adding to and removing from 3 corresponding
    // collections. This allows us to remove the overhead of manipulating
    // a monolithic collection of selected elements later.
    cy.on('select', 'node.noncluster, edge, node.cluster',
        function(e) {
            SELECTED_ELE_COUNT += 1;
            SELECTED_ELES = SELECTED_ELES.union(e.cyTarget);
            // If this is the first selected element, enable the
            // selectedInfo button
            if (SELECTED_ELE_COUNT === 1) {
                $("#selectedInfoButton").button("enable");
                $("#fitSelectedButton").button("enable");
            }
        }
    );
    cy.on('unselect', 'node.noncluster, edge, node.cluster',
        function(e) {
            SELECTED_ELE_COUNT -= 1;
            SELECTED_ELES = SELECTED_ELES.difference(e.cyTarget);
            // Not sure how we'd have a negative amount of selected
            // elements, but I figure we might as well cover our bases with
            // the <= 0 here :P
            if (SELECTED_ELE_COUNT <= 0) {
                $("#selectedInfoButton").button("disable");
                $("#fitSelectedButton").button("disable");
            }
        }
    );
    // NOTE this binding works -- when dragging a node, if any of its edges
    // become invalid then this automatically switches them to basicbezier
    // edges. It works great on smaller graphs, but on huge graphs it can
    // make dragging nodes painfully slow.
    // We can optimize this a bit by caching the node incomer/
    // outgoer lists (see initNodeAdjacents()), but we'd have to keep
    // those updated through collapsing.
    // And even with cached lists, this is pretty slow. I guess we could
    // somehow reduce the granularity of this (e.g. only register something
    // every other frame?), though? But then we'd want to keep this
    // reliable, also.
    // Also, this removes edges' control point info, meaning once an edge
    // has been modified to a basicbezier it stays that way until the graph
    // is reloaded. Not sure if there's a way to check if the edge is valid
    // (and change it back to an unbundledbezier) without using the
    // Cytoscape.js renderer, so this would only make sense for graphs we
    // want to generally have as static.
    // (Maybe make this an option for the user?) TODO get this faster
    //cy.on('drag', 'node',
    //    function(e) {
    //        var node = e.cyTarget;
    //        fixBadEdges(node.data("adjacentEdges"));
    //    }
    //);
    // TODO look into getting this more efficient in the future, if possible
    // (Renders labels only on tapping elements; doesn't really save that
    // much time, and might actually be less efficient due to the time taken
    // to register a tap event)
    //cy.on('tapstart', 'node',
    //    function(e) {
    //        var node = e.cyTarget;
    //        console.log(node);
    //        cy.style().selector("[id = '" + node.id() + "']").style({
    //            'label': 'data(id)'
    //        }).update();
    //    }
    //);
}

/* Rotates a node's position and, if applicable, its polygon definition.
 * NOTE that position of a compound node only seems to matter when that
 * compound node is collapsed -- as soon as that compound node regains
 * one or more of its children, its position is neglected again.
 */
function rotateNode(i, n) {
    // Rotate node position
    var oldPt = n.position();
    var newPt = rotateCoordinate(oldPt['x'], oldPt['y']);
    n.position({x: newPt[0], y: newPt[1]});
    // Rotate node polygon definition
    if (n.hasClass("noncluster")) { 
        // TODO Only use 8 polypts definitions: two per FWD/REV nodes per 4
        // possible graph rotations. Define these as global variables above,
        // instead of using .data() to store polypts (which is redundant for
        // many nodes).
        var coordList = n.data('polypts').trim().split(" ");
        var clLen = coordList.length;
        var pointList = [];
        var currPoint = [];
        for (var i = 0; i < clLen; i++) {
            if (i % 2 === 0) {
                // i/2 is always an integer, since i is even
                pointList[i / 2] =
                    [parseFloat(coordList[i]), parseFloat(coordList[i + 1])];
            }
        }
        n.data('polypts', rotateCoordinatesToStr(pointList));
    }
}

/* Modifies the graph's nodes and compound nodes "in situ" to move their
 * positions, along with rotating the control points of edges and the
 * definition of the house/invhouse node polygons.
 */
function changeRotation() {
    PREV_ROTATION = CURR_ROTATION;
    CURR_ROTATION = parseInt(document.getElementById("rotation").value);
    // We use the fit button's disabled status as a way to gauge whether or not
    // a graph is currently rendered; sorta hack-ish, but it works
    if (!$("#fitButton").button("option", "disabled")) {
        $("#progressbar").progressbar("value", false);
        window.setTimeout(function() {
            cy.startBatch();
            // This only rotates nodes that are not collapsed
            cy.filter('node').each(rotateNode);
            // Rotate nodes within currently collapsed node groups
            cy.scratch("_collapsed").each(function(i, n) {
                n.scratch("_interiorNodes").each(rotateNode);
            });
            cy.endBatch();
            cy.fit();
            $("#progressbar").progressbar("value", 100);
        }, 20);
    }
}

// If toUncollapseReady is false, changes the collapse button to say
// "Collapse All" with a minus icon.
// If toUncollapseReady is true, changes the collapse button to say
// "Uncollapse All" with a plus icon.
function changeCollapseButton(toUncollapseReady) {
    if (toUncollapseReady) {
        $("#collapseButton").button("option", "label",
            "Uncollapse All");
        $("#collapseButton").button("option", {icons:
            {primary: "ui-icon-plus"}});
    }
    else {
        $("#collapseButton").button("option", "label",
            "Collapse All");
        $("#collapseButton").button("option", {icons:
            {primary: "ui-icon-minus"}});
    }
}

// Clears the graph, to facilitate drawing another one.
// Assumes a graph has already been drawn (i.e. cy !== null)
function destroyGraph() {
    cy.destroy();
    changeCollapseButton(false);
}

/* Loads a .db file. */
function loadgraphfile() {
    var fr = new FileReader();
	var inputfile = document.getElementById('fileselector').files[0];
    if (inputfile === undefined) {
        alert("Please select a .db file to load.");
        return;
    }
    if (inputfile.name.endsWith(".db")) {
        // Important -- remove old DB from memory if it exists
        closeDB();
        changeVolatileControls("disable");
        $("#infoButton").button("disable");
        $("#currComponentInfo").html(
            "No connected component has been drawn yet.");
        fr.onload = function(e) {
            if (e.target.readyState === FileReader.DONE) {
                loadDBfile(e.target.result);
            }
        }
        // set progress bar to indeterminate state while we close
        // the old DB (if needed) and load the new DB file.
        // This isn't really that helpful on computers/fast-ish
        // systems, but for large DB files or mobile devices
        // (basically, anywhere sql.js might run slowly) this is
        // useful.
        // worth noting: we store this function call in an anonymous
        // function in order to delay its execution to when the
        // timeout happens
        // (javascript can be strange sometimes)
        $("#progressbar").progressbar("value", false);
        window.setTimeout(function() {
            fr.readAsArrayBuffer(inputfile);
        }, 50);
    }
    else {
        alert("Please select a valid .db file to load.");
    }
}

/* Runs prep. tasks for loading the database file and parsing its assembly +
 * component information
 */
function loadDBfile(fileData) {
    // Temporarily store .db file as array of 8-bit unsigned ints
    var uIntArr = new Uint8Array(fileData);
    CURR_DB = new SQL.Database(uIntArr);
    parseDBcomponents();
    // Set progressbar to "finished" state
    $("#progressbar").progressbar("value", 100);
}

/* Retrieves assembly-wide and component information from the database,
 * adjusting UI elements to prepare for component drawing accordingly.
 */
function parseDBcomponents() {
    // Get assembly-wide info from the graph
    if (cy !== null) {
        destroyGraph();
    }
    var stmt = CURR_DB.prepare("SELECT * FROM assembly;");
    stmt.step();
    var graphInfo = stmt.getAsObject();
    stmt.free();
    var fnInfo = graphInfo["filename"];
    var ftInfo = graphInfo["filetype"];
    ASM_NODE_COUNT = graphInfo["node_count"];
    var nodeInfo = ASM_NODE_COUNT.toLocaleString();
    var bpCt = graphInfo["total_length"];
    var bpInfo = bpCt.toLocaleString() + " bp";
    ASM_EDGE_COUNT = graphInfo["edge_count"];
    TOTAL_NE = ASM_NODE_COUNT + ASM_EDGE_COUNT;
    var edgeInfo = ASM_EDGE_COUNT.toLocaleString();
    var compCt = graphInfo["component_count"];
    var compInfo = compCt.toLocaleString();
    // Record N50
    var n50 = graphInfo["n50"];
    var n50Info = n50.toLocaleString() + " bp";
    // Record Assembly G/C content (not available for GML files)
    var asmGC = graphInfo["gc_content"];
    var asmGCInfo;
    if (asmGC !== null) {
        asmGCInfo = (asmGC * 100).toLocaleString() + "%";
    }
    else {
        asmGCInfo = "N/A";
    }
    // Adjust UI elements
    document.title = fnInfo;
    $("#filenameEntry").text(fnInfo); 
    $("#filetypeEntry").text(ftInfo);
    $("#nodeCtEntry").text(nodeInfo); 
    $("#totalBPLengthEntry").text(bpInfo); 
    $("#edgeCountEntry").text(edgeInfo);
    $("#connCmpCtEntry").text(compInfo);
    $("#n50Entry").text(n50Info);
    $("#asmGCEntry").text(asmGCInfo);
    $("#componentselector").spinner("option", "max", compCt);
    $("#componentselector").spinner("enable");
    $("#fileselectButton").button("enable");
    $("#infoButton").button("enable");
    $("#drawButton").button("enable");
    $("#rotation").selectmenu("enable");
}

/* Depending on the argument (either "enable" or "disable"),
 * either enables or disables some "volatile" (i.e. should be used atomically)
 * controls of the graph. (This will not enable the selectedInfoButton,
 * fitSelectedButton, or collapseButton, although it will disable them
 * if requested.)
 */
function changeVolatileControls(ableType) {
    $("#fileselectButton").button(ableType);
    $("#drawButton").button(ableType);
    $("#componentselector").spinner(ableType);
    $("#searchButton").button(ableType);
    if (ableType === "disable") {
        $("#selectedInfoButton").button("disable");
        $("#collapseButton").button("disable");
        $("#fitSelectedButton").button("disable");
    }
    $("#rotation").selectmenu(ableType);
    $("#fitButton").button(ableType);
    $("#exportButton").button(ableType);
}

function updateTextStatus(text) {
    $("#textStatus").html(text);
}

function startDrawComponent() {
    updateTextStatus("Drawing clusters...");
    window.setTimeout(drawComponent, 0);
}

/* Draws the selected connected component in the .db file -- its nodes, its
 * edges, its clusters -- to the screen.
 */
function drawComponent() {
    var cmpRank = $("#componentselector").spinner("value");
    if (!(Number.isInteger(cmpRank) && cmpRank >= 1
        && cmpRank <= $("#componentselector").spinner("option", "max"))) {
        alert("Please enter a valid component rank using the input field.");
        return;
    }
    changeVolatileControls("disable");
    // Okay, we can draw this component!
    if (cy !== null) {
        // If we already have a graph instance, clear that graph before
        // initializing another one
        // This should have already been called in parseDBcomponents(),
        // but since you can draw multiple components for the same .db file
        // we include this here as well
        destroyGraph();
    }
    initGraph();
    setGraphBindings();
    var componentNodeCount = 0;
    var componentEdgeCount = 0;
    SELECTED_ELES = cy.collection();
    SELECTED_ELE_COUNT = 0;
    PREV_ROTATION = 0;
    CURR_ROTATION = parseInt(document.getElementById("rotation").value);
    cy.scratch("_collapsed", cy.collection());
    cy.scratch("_uncollapsed", cy.collection());
    cy.scratch("_ele2parent", {});
    // Now we render the nodes, edges, and clusters of this component.
    // But first we need to get the bounding box of this component.
    // Along with the component's total node count.
    var bbStmt = CURR_DB.prepare(
        "SELECT boundingbox_x, boundingbox_y, node_count, edge_count FROM components WHERE " +
        "size_rank = ? LIMIT 1", [cmpRank]);
    bbStmt.step();
    var fullObj = bbStmt.getAsObject();
    bbStmt.free();
    var bb = {'boundingbox_x': fullObj['boundingbox_x'],
              'boundingbox_y': fullObj['boundingbox_y']};
    var totalElementCount = fullObj['node_count'] +
        (0.5 * fullObj['edge_count']); 
    // We need a fast way to associate node IDs with their x/y positions.
    // This is for calculating edge control point weight/distance.
    // And doing 2 DB queries (src + tgt) for each edge will take a lot of
    // time -- O(2|E|) time, specifically, with the only benefit of not
    // taking up a lot of space. So we go with the mapping solution -- it's
    // not particularly pretty, but it works alright.
    var node2pos = {};
    // We check to see if the component contains >= 1 cluster. If so, we
    // enable the collapse/uncollapse button; if not, we don't bother
    // enabling the button and keep it disabled because it'd be useless
    var clustersInComponent = false;
    cy.startBatch();
    var clustersStmt = CURR_DB.prepare(
        "SELECT * FROM clusters WHERE component_rank = ?", [cmpRank]);
    while (clustersStmt.step()) {
        clustersInComponent = true;
        renderClusterObject(clustersStmt.getAsObject(), bb);
    }
    clustersStmt.free();
    // Draw graph "iteratively" -- display all clusters.
    drawBoundingBoxEnforcingNodes(bb);
    cy.endBatch();
    cy.fit();
    updateTextStatus("Drawing nodes...");
    window.setTimeout(function() {
        /* I originally didn't have this wrapped in a timeout, but for some
         * reason a few clusters in the test BAMBUS E. coli assembly weren't
         * being rendered at the waiting point. It seemed some sort of race
         * condition was happening, and wrapping this block of code in a
         * timeout seems to solve the problem for iterative cluster drawing
         * (iterative node/edge drawing is fine, since those already use
         * timeouts to update the progress bar).
         */
        cy.startBatch();
        var nodesStmt = CURR_DB.prepare(
            "SELECT * FROM nodes WHERE component_rank = ?", [cmpRank]);
        CURR_NE = 0;
        drawComponentNodes(nodesStmt, bb, cmpRank, node2pos,
            clustersInComponent, componentNodeCount, componentEdgeCount,
            totalElementCount);
    }, 0);
}

function drawComponentNodes(nodesStmt, bb, cmpRank, node2pos,
        clustersInComponent, componentNodeCount, componentEdgeCount,
        totalElementCount) {
    var currNode;
    if (nodesStmt.step()) {
        currNode = nodesStmt.getAsObject();
        renderNodeObject(currNode, bb);
        // TODO inefficiency -- only call gv2cyPoint once. We call it once
        // in renderNodeObject() and once here. To rectify, call after
        // init'ing currNode and then pass to renderNodeObject().
        node2pos[currNode['id']] = gv2cyPoint(
            currNode['x'], currNode['y'],
            [bb['boundingbox_x'], bb['boundingbox_y']]
        );
        componentNodeCount += 1;
        CURR_NE += 1;
        if (CURR_NE % PROGRESS_BAR_UPDATE_FREQ === 0) {
            $("#progressbar").progressbar("value",
                (CURR_NE / totalElementCount) * 100);
            window.setTimeout(function() {
                drawComponentNodes(nodesStmt, bb, cmpRank, node2pos,
                    clustersInComponent, componentNodeCount,
                    componentEdgeCount, totalElementCount);
            }, 0);
        }
        else {
            drawComponentNodes(nodesStmt, bb, cmpRank, node2pos,
                clustersInComponent, componentNodeCount, componentEdgeCount,
                totalElementCount);
        }
    }
    else {
        nodesStmt.free();
        // Second part of "iterative" graph drawing: draw all nodes
        cy.endBatch();
        cy.fit();
        updateTextStatus("Drawing edges...");
        cy.startBatch();
        // NOTE that we intentionally only consider edges within this component
        // Multiplicity is an inherently relative measure, so outliers in other
        // components will just mess things up in the current component.
        var maxMult, minMult;
        var maxMultiplicityStmt = CURR_DB.prepare(
            "SELECT * FROM edges WHERE component_rank = ? " +
            "ORDER BY multiplicity DESC LIMIT 1", [cmpRank]);
        maxMultiplicityStmt.step();
        maxMult = maxMultiplicityStmt.getAsObject()['multiplicity'];
        maxMultiplicityStmt.free();
        // If the assembly doesn't have edge multiplicity data, don't bother
        // trying to find the minimum -- that'll also be null.
        if (maxMult !== null) {
            var minMultiplicityStmt = CURR_DB.prepare(
                "SELECT * FROM edges WHERE component_rank = ? " + 
                "ORDER BY multiplicity LIMIT 1", [cmpRank]);
            minMultiplicityStmt.step();
            minMult = minMultiplicityStmt.getAsObject()['multiplicity'];
            minMultiplicityStmt.free();
        }
        else {
            minMult = null;
        }
        var edgesStmt = CURR_DB.prepare(
            "SELECT * FROM edges WHERE component_rank = ?", [cmpRank]);
        drawComponentEdges(edgesStmt, bb, node2pos, maxMult, minMult, cmpRank,
            clustersInComponent, componentNodeCount, componentEdgeCount,
            totalElementCount);
    }
}

function drawComponentEdges(edgesStmt, bb, node2pos, maxMult, minMult, cmpRank,
        clustersInComponent, componentNodeCount, componentEdgeCount,
        totalElementCount) {
    if (edgesStmt.step()) {
        renderEdgeObject(edgesStmt.getAsObject(), node2pos,
            maxMult, minMult, bb, componentNodeCount, componentEdgeCount,
            totalElementCount);
        componentEdgeCount += 1;
        CURR_NE += 0.5;
        if (CURR_NE % PROGRESS_BAR_UPDATE_FREQ === 0) {
            $("#progressbar").progressbar("value",
                (CURR_NE / totalElementCount) * 100);
            window.setTimeout(function() {
                drawComponentEdges(edgesStmt, bb, node2pos, maxMult, minMult,
                    cmpRank, clustersInComponent, componentNodeCount,
                    componentEdgeCount, totalElementCount);
            }, 0);
        }
        else {
            drawComponentEdges(edgesStmt, bb, node2pos, maxMult, minMult,
                cmpRank, clustersInComponent, componentNodeCount,
                componentEdgeCount, totalElementCount);
        }
    }
    else {
        edgesStmt.free();
        removeBoundingBoxEnforcingNodes(bb);
        finishDrawComponent(cmpRank, componentNodeCount, componentEdgeCount,
            clustersInComponent);
    }
}

function finishDrawComponent(cmpRank, componentNodeCount, componentEdgeCount,
        clustersInComponent) {
    updateTextStatus("&nbsp;");
    var intro = "The ";
    var nodePercentage = (componentNodeCount / ASM_NODE_COUNT) * 100;
    var edgePercentage = (componentEdgeCount / ASM_EDGE_COUNT) * 100;
    var all_nodes_edges_modifier = "the";
    if ($("#filetypeEntry").text() !== "GraphML") {
        intro = "Including <strong>both positive and negative</strong>" +
            " nodes and edges, the ";
        nodePercentage /= 2;
        edgePercentage /= 2;
        all_nodes_edges_modifier = "all positive and negative";
    }
    // This is incredibly minor, but I always get annoyed at software that
    // doesn't use correct grammar for stuff like this nowadays :P
    var nodeNoun = (componentNodeCount === 1) ? "node" : "nodes";
    var edgeNoun = (componentEdgeCount === 1) ? "edge" : "edges";
    $("#currComponentInfo").html(intro + "current component (size rank "
       + cmpRank + ") has <strong>" + componentNodeCount + " " + nodeNoun
       + "</strong> and <strong>" + componentEdgeCount + " " + edgeNoun
       + "</strong>. This component contains <strong>"
       + nodePercentage.toFixed(2) + "% of " + all_nodes_edges_modifier
       + " nodes</strong> in the assembly and <strong>"
       + edgePercentage.toFixed(2) + "% of " + all_nodes_edges_modifier
       + " edges</strong> in the assembly.");
    // NOTE modified initClusters() to do cluster height after the fact.
    // This represents an inefficiency when parsing xdot files, although it
    // shouldn't really affect anything major.
    initClusters();
    cy.endBatch();
    cy.fit();
    fixBadEdges();
    changeVolatileControls("enable");
    cy.userPanningEnabled(true);
    cy.userZoomingEnabled(true);
    cy.boxSelectionEnabled(true);
    cy.autounselectify(false);
    cy.autoungrabify(false);
    if (clustersInComponent) {
        $("#collapseButton").button("enable");
    }
    else {
        $("#collapseButton").button("disable");
    }
    $("#progressbar").progressbar("value", 100);
}

// TODO verify that this doesn't mess stuff up when you back out of and then
// return to the page. Also are memory leaks even a thing that we have
// to worry about in Javascript?????????
function closeDB() {
    if (CURR_DB !== null) {
        CURR_DB.close();
    }
}

/* Following two functions are for loading server-side .db files, located
 * in the same directory as this script. Note that #fsDialog might not
 * refer to an actual div, depending on what HTML page uses this file, so
 * it's important to make sure the prerequisite features are there before
 * using this particular infrastructure.
 */
function openFileSelectDialog() {
    $("#fsDialog").dialog("open"); 
    scaleDialog("#fsDialog");
}

function loadajaxDB() {
    // Important -- remove old DB from memory if it exists
    closeDB();
    // usually we won't have the luxury of ID === filename, but this is a
    // demo so might as well
    $("#fsDialog").dialog("close");
    changeVolatileControls("disable");
    $("#infoButton").button("disable");
    $("#currComponentInfo").html(
        "No connected component has been drawn yet.");
    var filename = $("input[name=fs]:checked").attr('id');
    // jQuery doesn't support arraybuffer responses so we have to manually
    // use an XMLHttpRequest(), strange capitalization and all
    // Credit to this approach goes here, btw:
    // http://www.henryalgus.com/reading-binary-files-using-jquery-ajax/
    var xhr = new XMLHttpRequest();
    xhr.open("GET", filename, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = function(eve) {
        if (this.status === 200) {
            loadDBfile(this.response);
        }
    };
    $("#progressbar").progressbar("value", false);
    xhr.send();
}
/* End server-side.db specific functions */

/* Pops up a dialog displaying assembly information. */
function displayInfo() {
    $("#infoDialog").dialog("open");
    scaleDialog("#infoDialog");
}

/* Pops up a dialog displaying information about selected nodes/edges.
 * Note that we gather the info to be stored in this dialog upon opening
 * the dialog, rather than as we select elements in the graph:
 * I think this approach works better because it adds no overhead when
 * selecting elements, only when the user decides to inspect those elements
 * in particular.
 */
function displaySelectedInfo() {
    if ($("#selectedInfoDialog").dialog("isOpen")) {
        // If the dialog's already open then don't do anything.
        // I suppose we could have these buttons toggle the visibility of their
        // respective dialogs, but not sure of the UI implications of that.
        // In any case, this should prevent problems for now.
        return;
    }
    var selectedNodes = SELECTED_ELES.filter("node.noncluster");
    var selectedEdges = SELECTED_ELES.filter("edge");
    var selectedClusters = SELECTED_ELES.filter("node.cluster");
    var content;
    if (selectedNodes.nonempty()) {
        // Populate node table
        $("#nodeInfoTable").show();
        content = NODE_TABLE_HEADER;
        var existsDNA = true;
        selectedNodes.each(function(i, n) {
            // TODO abstract repetitive null-checking to sep func?
            var lengthEntry, depthEntry, dnaEntry, gcEntry;
            if (n.data("length") == null) {
                lengthEntry = "N/A";
            }
            else {
                lengthEntry = n.data("length").toLocaleString() + " nt";
            }
            if (n.data("depth") == null) {
                depthEntry = "N/A";
            }
            else {
                depthEntry = n.data("depth").toLocaleString() + "x";
            }
            if (n.data("gc_content") == null) {
                gcEntry = "N/A";
            }
            else {
                gcEntry = (n.data("gc_content") * 100).toLocaleString() + "%";
            }
            if (!n.data("hasDNA")) {
                existsDNA = false;
                NODES_TO_QUERY = [];
            }
            content += "<tr><td>" + n.id() + "</td><td>" + lengthEntry +
                "</td><td>" + depthEntry + "</td><td>" + gcEntry +
                "</td></tr>";
            // Save the node's ID for if the user requests DNA info
            // We check existsDNA to avoid using up memory if the selected
            // nodes don't have any DNA
            if (existsDNA) {
                NODES_TO_QUERY.push(n.id());
            }
        });
        $("#nodeInfoTable").append(content);
        if (existsDNA) {
            $("#selectedInfoDialog").next(".ui-dialog-buttonpane").prop(
                "disabled", false).removeClass("ui-state-disabled");
        }
        else {
            // If at least one of the nodes doesn't have DNA associated w/ it,
            // disable the "copy DNA" button
            $("#selectedInfoDialog").next(".ui-dialog-buttonpane").prop(
                "disabled", true).addClass("ui-state-disabled");
        }
    }
    else {
        $("#nodeInfoTable").hide();
        $("#selectedInfoDialog").next(".ui-dialog-buttonpane").prop(
            "disabled", true).addClass("ui-state-disabled");
    }
    if (selectedEdges.nonempty()) {
        // Populate edge table
        $("#edgeInfoTable").show();
        content = EDGE_TABLE_HEADER;
        selectedEdges.each(function(i, e) {
            var multEntry = e.data("mult");
            if (multEntry == null) {
                multEntry = "N/A";
            }
            content += "<tr><td>" + e.data("source") + "</td><td>" +
                e.data("target") + "</td><td>" + multEntry + "</td></tr>";
        });
        $("#edgeInfoTable").append(content);
    }
    else {
        $("#edgeInfoTable").hide();
    }
    // TODO set existsDNA or something as a global variable for the assembly,
    // and use that to determine whether or not to open the "export DNA"
    // buttons and, then, to display this cluster's DNA
    if (selectedClusters.nonempty()) {
        // Populate edge table
        $("#clusterInfoTable").show();
        content = CLUSTER_TABLE_HEADER;
        selectedClusters.each(function(i, c) {
            var clustID = c.data("id");
            var clustType;
            if (clustID[0] === 'C') clustType = "Chain";
            else if (clustID[0] === 'Y') clustType = "Cyclic Chain";
            else if (clustID[0] === 'B') clustType = "Bubble";
            else if (clustID[0] === 'R') clustType = "Frayed Rope";
            else clustType = "Invalid (error)";
            var clustSize = c.scratch("_interiorNodes").size(); 
            content += "<tr><td>" + clustID + "</td><td>" +
                clustType + "</td><td>" + clustSize + "</td></tr>";
        });
        $("#clusterInfoTable").append(content);
    }
    else {
        $("#clusterInfoTable").hide();
    }
 
    $("#selectedInfoDialog").dialog("open");
    scaleDialog("#selectedInfoDialog");
}

// Clear node/edge info tables in selected node/edge dialog
function clearInfoTables(ev, ui) {
    $("#nodeInfoTable tr").remove();
    $("#edgeInfoTable tr").remove();
    $("#clusterInfoTable tr").remove();
    // Clear NODES_TO_QUERY
    NODES_TO_QUERY.length = 0;
}

/* Return a single string containing the DNA sequences of the selected
 * nodes, in FASTA format.
 */
function getSelectedNodeDNA() {
    // Get DNA sequences from database file, and append them to a string
    var dnaStmt;
    var dnaSeqs = "";
    var currDnaSeq;
    var seqIndex;
    var afterFirstSeqLine;
    for (var i = 0; i < NODES_TO_QUERY.length; i++) {
        // TODO Is there any way to make this more efficient? Like, via
        // selecting multiple dnafwd values at once...?
        dnaStmt = CURR_DB.prepare("SELECT dnafwd FROM nodes WHERE id = ?",
            [NODES_TO_QUERY[i]]);
        dnaStmt.step();
        if (i > 0) {
            dnaSeqs += "\n";
        }
        dnaSeqs += ">NODE_" + NODES_TO_QUERY[i] + "\n";
        afterFirstSeqLine = false;
        currDnaSeq = dnaStmt.getAsObject()['dnafwd'];
        for (seqIndex = 0; seqIndex < currDnaSeq.length; seqIndex += 70) {
            if (afterFirstSeqLine) {
                dnaSeqs += "\n";
            }
            else {
                afterFirstSeqLine = true;
            }
            dnaSeqs += currDnaSeq.substring(seqIndex, seqIndex + 70);
        }
        dnaStmt.free();
    }
    return dnaSeqs;
}
 
// Pop up *another* dialog for copying?
function copySelectedNodeDNA() {
    $("#dnaTextArea").text(getSelectedNodeDNA());
    // Select it, to enable quick copying-to-clipboard
    $("#dnaTextArea").select();
    $("#dnaDialog").dialog("open");
    scaleDialog("#dnaDialog");
}

/* Exports selected node DNA to a FASTA file via a data URI. */
function exportSelectedNodeDNA() {
    window.open(
        "data:text/FASTA;charset=utf-8;base64," +
        window.btoa(getSelectedNodeDNA()),
        "_blank"
    );
}

// Scales down the dialog so that its width is no more than 75% of the
// window width and its height is no more than 60% of the window height
// The dialog should already be open when this function is called (otherwise
// its width/height might be set to 0)
function scaleDialog(dialogID) {
    var maxDialogWidth = $(window).width() * 0.75;
    var maxDialogHeight = $(window).height() * 0.6;
    if ($(dialogID).width() > maxDialogWidth) {
        $(dialogID).dialog("option", "width", maxDialogWidth);
    }
    if ($(dialogID).height() > maxDialogHeight) {
        $(dialogID).dialog("option", "height", maxDialogHeight);
    }
}

/* Fits the graph to all its elements if toSelected is false, and to only
 * selected elements if toSelected is true.
 */
function fitGraph(toSelected) {
    $("#progressbar").progressbar("value", false);
    window.setTimeout(
        function() {
            if (toSelected) {
                // Right now, we don't throw any sort of error here if
                // SELECTED_ELES is empty. We could, though?
                cy.fit(SELECTED_ELES);
            } else {
                cy.fit();
            }
            $("#progressbar").progressbar("value", 100);
        }, 20
    );
}

/* Exports PNG image of graph. */
function exportGraph() {
    // open PNG data URI repr of graph in new window/tab (whether window or tab
    // is chosen is browser+user dependent; "_blank" is sufficient)
    window.open(cy.png(), "_blank");
}

// Displays the search dialog
function showSearchDialog() {
    $("#searchDialog").dialog("open");
    scaleDialog("#searchDialog");
}

function disableTooltip() {
    $(document).tooltip("disable");
}

function enableTooltip() {
    $(document).tooltip("enable");
}

// Simple shortcut used to enable searching by pressing Enter (charCode 13)
function searchWithEnter(e) {
    if (e.charCode === 13) {
        searchForNode();
    }
}

// Centers the graph on a given node (edges/clusters can also be specified,
// using Node1->Node2 or [B/R/C]Node1_Node2_Node3... syntax respectively.)
function searchForNode() {
    var nodes =
        document.getElementById('nodeselector').value.split(",");
    var nodeEles = cy.collection(); // empty collection (for now)
    var newEle;
    var parentID;
    for (var c = 0; c < nodes.length; c++) {
        newEle = cy.getElementById(nodes[c].trim());
        if (newEle.empty()) {
            // Check if this element is in the graph (but currently
            // collapsed, and therefore inaccessible) or if it just
            // never existed in the first place
            parentID = cy.scratch("_ele2parent")[nodes[c].trim()];
            if (parentID !== undefined) {
                // We've collapsed the parent of this element, so identify
                // its parent instead
                nodeEles = nodeEles.union(cy.getElementById(parentID));
            }
            else {
                // It's a bogus element
                alert("Error -- element ID " + nodes[c].trim() +
                      " is not in this component.");
                return;
            }
        }
        else {
            // Identify the node in question
            nodeEles = nodeEles.union(newEle);
        }
    }
    // Fit the graph to the identified nodes.
    cy.fit(nodeEles);
    // Unselect all previously-selected nodes
    // (TODO: is this O(n)? because if so, it's not worth it, probably)
    // (Look into this)
    cy.filter(':selected').unselect();
    // Select all identified nodes, so they can be dragged if desired
    // (and also to highlight them).
    nodeEles.select();
}

/* Determines whether collapsing or uncollapsing should be performed,
 * updates the status div accordingly, and begins the (un)collasping
 * process.
 */
function startCollapseAll() {
    var currVal = $("#collapseButton").button("option", "label");
    $("#progressbar").progressbar("value", false);
    window.setTimeout(function() { collapseAll(currVal[0]) }, 50);
}

/* Collapse/uncollapse all compound nodes in the graph.
 * This just delegates to collapseCluster() and uncollapseCluster().
 * An argument of 'U' uncollapses all nodes, and an argument of 'C' (or
 * anything that isn't 'U') collapses all nodes.
 */
function collapseAll(operationCharacter) { 
    cy.startBatch();
    if (operationCharacter === 'U') {
        cy.scratch("_collapsed").each(
            function(i, cluster) {
                uncollapseCluster(cluster);
            }
        );
    }
    else {
        cy.scratch("_uncollapsed").each(
            function(i, cluster) {
                collapseCluster(cluster);
            }
        );
    }
    $("#progressbar").progressbar("value", 100);
    cy.endBatch();
}

/* Simple classes (well, not really classes, but they're basically as
 * close as you can get in Javascript?) defining attributes of
 * nodes/edges/clusters.
 */
function Node(id, x, y, width, height, shape) {
    this.id = id;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.shape = shape; // can be either "house" or "invhouse"
}

function Edge(sourceID, sinkID) {
    this.sourceID = sourceID;
    this.sinkID = sinkID;
    // We use a -> in the edge ID instead of just concatenating the
    // source and sink IDs. I was originally just concatenating the
    // IDs, but that actually caused a problem when I had an edge
    // between nodes "c3" and "9" -- it made the edge's ID "c39",
    // conflicting with the actual node with the ID "c39"!
    // I'm pretty sure - and > are illegal characters for GraphViz
    // node IDs, so this should be safe.
    // NOTE for future reference: the error message I got in the
    // dev. console said Cytoscape.js couldn't add another
    // "element" with the ID "c39". Turns out "element" can mean
    // either node or edge...
    this.id = this.sourceID + "->" + this.sinkID;
    this.ctrlPts = [];
    // Number of control points this edge has; obtained directly from xdot
    // file's information (defined in _draw_ as B n, where n is the number
    // of control points)
    // Useful for testing, I guess.
    this.ctrlPtNum = 0;    
    // String used as intermediate format to store ctrl points
    this.ctrlPtStr = "";
}

function Cluster(id, nodes, edges) {
    this.id = id;
    this.nodes = nodes;
    this.edges = edges;
}

// Converts an angle in degrees to radians (for use with Javascript's trig
// functions)
function degreesToRadians(angle) {
    return angle * (Math.PI / 180);
}

// Rotates a coordinate by a given clockwise angle (in degrees).
// Returns an array of [x', y'] representing the new point.
function rotateCoordinate(xCoord, yCoord) {
    // NOTE The formula for a coordinate transformation here works for all
    // degree inputs of rotation. However, to save time, we just check
    // to see if the rotation is a factor of 360 (i.e. the rotated
    // point would be the same as the initial point), and if so we just
    // return the original coordinates.
    var rotation = PREV_ROTATION - CURR_ROTATION;
    if (rotation % 360 === 0) {
        return [xCoord, yCoord];
    }
    else {
        var newX = (xCoord * Math.cos(degreesToRadians(rotation)))
                    - (yCoord * Math.sin(degreesToRadians(rotation)));
        var newY = (yCoord * Math.cos(degreesToRadians(rotation)))
                    + (xCoord * Math.sin(degreesToRadians(rotation)));
        newX = parseFloat(newX.toFixed(2));
        newY = parseFloat(newY.toFixed(2));
        return [newX, newY];
    }
}

// Used for angles not divisible by 90 degrees. Technically this is used for
// 180, 270, etc, but those are due to rounding errors (only an
// infinitesimal part of the polygon is lost, so it doesn't really count)
function boundCoordinate(coord, lowerBound, upperBound) {
    if (coord >= lowerBound) {
        if (coord <= upperBound) {
            return coord;
        }
        else {
            return upperBound;
        }
    }
    else {
        return lowerBound;
    }
}

/* Given an array of [x, y] coordinates (e.g. [[0, 0], [-1, 1], [0.5, 0]]),
 * rotates each coordinate about the axis by the specified
 * rotation angle (in degrees), returning a Cytoscape.js-acceptable string
 * of the points in the format "x1 y1 x2 y2"..."xn yn".
 */
function rotateCoordinatesToStr(coordinateList) {
    var outputString = "";
    var currCoord, rotatedCoord;
    var newX, newY;
    for (var c = 0; c < coordinateList.length; c++) {
        currCoord = coordinateList[c];
        rotatedCoord = rotateCoordinate(currCoord[0], currCoord[1]);
        outputString += boundCoordinate(rotatedCoord[0], -1, 1) + " ";
        outputString += boundCoordinate(rotatedCoord[1], -1, 1) + " ";
    }
    return outputString.trim();
}

/* Given the bounding box of the graph, a graph rotation angle (in degrees),
 * and a point specified by x and y coordinates, converts the point from
 * GraphViz' coordinate system to Cytoscape.js' coordinate system, rotating
 * the point if necessary (i.e. the rotation angle mod 360 !== 0).
 *
 * For reference -- GraphViz uses the standard Cartesian system in which
 * the bottom-left corner of the screen is the origin, (0, 0). Cytoscape.js
 * inverts the y-axis, with the origin (0, 0) being situated at the
 * top-right corner of the screen. So to transform a point (x, y) from
 * GraphViz to Cytoscape.js, you just return (x, y'), where
 * y' = the vertical length of the bounding box, minus y.
 * (The x-coordinate remains the same.)
 *
 * This is a purposely simple function -- in the event that we decide to
 * use another graphing library/layout system/etc. for some reason, we can
 * just modify this function accordingly.
 */
function gv2cyPoint(xCoord, yCoord, boundingbox) {
    // Convert from GraphViz to Cytoscape.js
    var cyY = boundingbox[1] - yCoord;
    var cyX = xCoord;
    // Rotate the point about the axis if necessary
    return rotateCoordinate(cyX, cyY);
}

/* Converts a string of control points (defined in the form "x1 y1 x2 y2",
 * for an arbitrary number of points) to a 2-dimensional list of floats,
 * of the form [[x1, y1], [x2, y2], ...]. If the input string contains an
 * odd number of coordinate components for some reason (e.g.
 * "x1 y1 x2 y2 x3") then this will return null, since that's invalid.
 * This also takes care of converting each point in the input string from
 * GraphViz' coordinate system to Cytoscape.js' coordinate system.
 * (Hence why the graph's bounding box and rotation are parameters here.)
 */
function ctrlPtStrToList(ctrlPointStr, boundingbox) {
    // Create coordList, where every coordinate is an element (e.g.
    // [x1, y1, x2, y2, ...]
    var coordList = ctrlPointStr.trim().split(" ");
    // Merge two elements of coordList at a time. NOTE that this is only
    // possible when coordList.length is even, so this is why we have to
    // wait until we're finished parsing all control points until doing
    // this conversion. (If coordList.length is odd, return null --
    // something went very wrong in that case.)
    var clLen = coordList.length;
    if (clLen % 2 !== 0) {
        return null;
    }
    else {
        var pointList = [];
        var currPoint = [];
        for (var i = 0; i < clLen; i++) {
            if (i % 2 === 0) {
                // i/2 is always an integer, since i is even
                pointList[i / 2] = gv2cyPoint(
                        parseFloat(coordList[i]),
                        parseFloat(coordList[i + 1]),
                        boundingbox
                );
            }
        }
        return pointList;
    }
}

// Identifies invalid (per Cytoscape.js) edges and converts them to basic
// bezier edges that can be properly rendered.
// If provided, will only check edgeList.
function fixBadEdges(edgeList) {
    cy.batch(
        function() {
            if (edgeList === undefined) {
                cy.filter('edge.unbundledbezier').each(fixSingleEdge);
            }
            else {
                edgeList.each(fixSingleEdge);
            }
        }
    );
}

/* If the given edge is a badBezier or badLine, converts it to a basicbezier
 * NOTE that this class should be called from within a batch operation, to
 * prevent style class collisions.
 */
function fixSingleEdge(i, e) {
    if (e._private.rscratch['badBezier'] || e._private.rscratch['badLine']) {
        e.removeClass('unbundledbezier');
        e.removeData('cpd');
        e.removeData('cpw');
        e.addClass('basicbezier');
    }
}

/* NOTE -- this is an unused function right now. Could be useful in the future,
 * perhaps.
 * Initializes the adjacent edges (i.e. incoming + outgoing edges) of
 * every non-cluster node in the graph. This would be useful if we
 * enabled dynamic edge validity checking (it makes checking each node's
 * edges more efficient, since we only have to build up these collections
 * once), but for now dynamic edge validity checking is disabled due to
 * still being too slow.
 */
function initNodeAdjacents() {
    cy.filter('node.noncluster').each(
        function(i, node) {
            node.data("adjacentEdges",
                node.incomers('edge').union(node.outgoers('edge'))
            );
        }
    );
}

// Records actual and canonical incoming/outgoing edges of clusters in the
// data of the cluster, as incomingEdges and outgoingEdges (actual
// edges in the graph) and cSource and cTarget (canonical source/target).
// This is going to involve iterating over every compound node in the graph.
// See collapse() for guidance on how to do that, I guess.
// NOTE that we delay doing this work until after everything else has been
// rendered in order to ensure that all edges/nodes necessary for this have
// already been rendered.
function initClusters() {
    // For each compound node...
    cy.scratch("_uncollapsed").each(
        function(i, node) {
            var children = node.children();        
            // Unfiltered incoming/outgoing edges
            var uIncomingEdges = children.incomers('edge');
            var uOutgoingEdges = children.outgoers('edge');
            // Actual incoming/outgoing edges -- will be move()'d as
            // this cluster/adjacent cluster(s) are collapsed/uncollapsed
            var incomingEdges  = uIncomingEdges.difference(uOutgoingEdges);
            var outgoingEdges  = uOutgoingEdges.difference(uIncomingEdges);
            // Mapping of edge ID to [cSource, cTarget]
            // Used since move() removes references to edges, so storing IDs
            // is more permanent
            var incomingEdgeMap = {};
            var outgoingEdgeMap = {};
            // "Canonical" incoming/outgoing edge properties -- these
            // are used to represent the ideal connections
            // between nodes regardless of collapsing
            incomingEdges.each(
                function(j, edge) {
                    incomingEdgeMap[edge.id()] =
                        [edge.source().id(), edge.target().id()];
                }
            );
            outgoingEdges.each(
                function(j, edge) {
                    outgoingEdgeMap[edge.id()] =
                        [edge.source().id(), edge.target().id()];
                }
            );
            // Get the "interior elements" of the cluster: all child nodes,
            // plus the edges connecting child nodes within the cluster
            // This considers cyclic edges (e.g. the edge connecting a
            // cycle's "end" and "start" nodes) as "interior elements,"
            // which makes sense as they don't connect the cycle's children
            //  to any elements outside the cycle.
            var interiorEdges = children.connectedEdges().difference(
                incomingEdges).difference(outgoingEdges);
            var wid = 0;
            var hgt = 0;
            // Basically, a cluster's width and height should be
            // reflective of the widths and heights of its children.
            // In the children.each block here we basically add the
            // approximate DNA lengths of each child (as reflected
            // in the width/height of the child node in question) to
            // an accumulator, and after the block we treat these
            // values like we treat normal node blocks and scale them
            // the same way (logarithmically).
            children.each(function(i,e) {
                wid += Math.pow(10, e.data("w") / INCHES_TO_PIXELS);
                hgt += Math.pow(10, e.data("h") / INCHES_TO_PIXELS);
            });
            wid = INCHES_TO_PIXELS * (Math.log(wid) / Math.log(10));
            hgt = INCHES_TO_PIXELS * (Math.log(hgt) / Math.log(10));
            // Record incoming/outgoing edges in this
            // cluster's data. Will be useful during collapsing.
            // We also record "interiorNodes" -- having a reference to just
            // these nodes saves us the time of filtering nodes out of
            // interiorEles when rotating collapsed node groups.
            node.data({
                "incomingEdgeMap": incomingEdgeMap,
                "outgoingEdgeMap": outgoingEdgeMap,
                "w"              : wid,
                "h"              : hgt
            });
            // We store collections of elements in the cluster's scratch data.
            // Storing it in the main "data" section will mess up the JSON
            // exporting, since it isn't serializable.
            // TODO reduce redundancy here -- only store interiorEles, and in
            // rotateNodes just select nodes from interiorEles
            node.scratch({
                "_interiorEles": interiorEdges.union(children),
                "_interiorNodes": children
            });
        }
    );
}

// Renders a given node object, obtained by getAsObject() from running a
// query on CURR_DB for selecting rows from table nodes.
function renderNodeObject(nodeObj, boundingboxObject) {
    // TODO find a way to only do this once per render job -- no need to
    // recalc it n times, that's just stupid
    if (nodeObj['shape'] === 'house') {
        var nodePolygonPts = rotateCoordinatesToStr(HOUSE_POLYPTS);
    }
    else {
        var nodePolygonPts = rotateCoordinatesToStr(INVHOUSE_POLYPTS);
    }
    var pos = gv2cyPoint(nodeObj['x'], nodeObj['y'],
        [boundingboxObject['boundingbox_x'],
         boundingboxObject['boundingbox_y']]);
    var nodeID = nodeObj['id'];
    // NOTE that NULL in sqlite gets translated to Javascript as null, which
    // works perfectly for our use of the node parent field.
    // Hence why we can just use the parent_cluster_id field directly.
    var parentID = nodeObj['parent_cluster_id'];
    var gc = nodeObj['gc_content'];
    var bg_color = "#";
    if (gc !== null && gc !== undefined) {
        var red_i = gc * 255;
        var green = "22";
        var blue_i = 255 - red_i;
        var red = Math.floor(red_i).toString(16);
        var blue = Math.floor(blue_i).toString(16);
        if (red.length === 1) {
            red = "0" + red;
        }
        if (blue.length === 1) {
            blue = "0" + blue;
        }
        bg_color += (red + green + blue);
    }
    else {
        bg_color += "999999";
    }
    cy.add({
        classes: 'noncluster',
        data: {id: nodeID, parent: parentID, polypts: nodePolygonPts, 
               w: INCHES_TO_PIXELS * nodeObj['w'],
               h: INCHES_TO_PIXELS * nodeObj['h'],
               house: nodeObj['shape'] === 'house', depth: nodeObj['depth'],
               // TODO: if we settle on always calculating G/C content when DNA
               // is available, then we can use the gc_content variable as a
               // flag for null instead of the explicit hasDNA data value.
               length: nodeObj['length'], hasDNA: nodeObj['dnafwd'] !== null,
               gc_content: gc, bg_color: bg_color},
        position: {x: pos[0], y: pos[1]}
    });
    if (parentID !== null) {
        cy.scratch("_ele2parent")[nodeID] = parentID;
    }
}

// Draws two invisible nodes that "enforce" the given bounding box.
function drawBoundingBoxEnforcingNodes(boundingboxObject) {
    var bb = [boundingboxObject['boundingbox_x'],
              boundingboxObject['boundingbox_y']];
    var bottomLeftPt = gv2cyPoint(0, 0, bb);
    var topRightPt = gv2cyPoint(bb[0], bb[1], bb);
    cy.add({
        classes: "bb_enforcing",
        data: {id: "bottom_left", w: 0, h: 0},
        position: {x: bottomLeftPt[0], y: bottomLeftPt[1]}
    });
    cy.add({
        classes: "bb_enforcing",
        data: {id: "top_right", w: 0, h: 0},
        position: {x: topRightPt[0], y: topRightPt[1]}
    });
}

function removeBoundingBoxEnforcingNodes(boundingboxObject) {
    cy.$("node.bb_enforcing").remove();
}

// Renders a cluster object.
function renderClusterObject(clusterObj, boundingboxObject) {
    var clusterID = clusterObj["cluster_id"];
    var bottomLeftPos = gv2cyPoint(clusterObj['left'], clusterObj['bottom'],
        [boundingboxObject['boundingbox_x'],
         boundingboxObject['boundingbox_y']]);
    var topRightPos = gv2cyPoint(clusterObj['right'], clusterObj['top'],
        [boundingboxObject['boundingbox_x'],
         boundingboxObject['boundingbox_y']]);
    cy.scratch("_uncollapsed", cy.scratch("_uncollapsed").union(
        cy.add({
            classes: clusterID[0] + ' cluster',
            data: {id: clusterID,
                w: Math.abs(topRightPos[0] - bottomLeftPos[0]),
                h: Math.abs(topRightPos[1] - bottomLeftPos[1]),
                isCollapsed: false},
            position: {x: (bottomLeftPos[0] + topRightPos[0]) / 2,
                       y: (bottomLeftPos[1] + topRightPos[1]) / 2}
        })
    ));
}

/* Renders edge object. Hopefully in a not-terrible way.
 *
 * Uses node2pos (mapping of node object from DB -> [x, y] position)
 * to calcluate relative control point weight stuff.
 *
 * This also relatively scales edge thickness based on multiplicity.
 * NOTE that we don't scale edge thickness when using dot from collate.py,
 * since GraphViz doesn't adjust node placement based on edge thickness even
 * in extreme cases -- therefore we have free reign in this function to
 * adjust edge thickness, independent of the other parts of AsmViz.
 */
function renderEdgeObject(edgeObj, node2pos, maxMult, minMult,
        boundingboxObject) {
    var sourceID = edgeObj['source_id'];
    var targetID = edgeObj['target_id'];
    var multiplicity = edgeObj['multiplicity'];
    // Default edge width setting of Cytoscape.js
    var edgeWidth = 3;
    // This discounts multiplicity data if:
    // -All edges have same multiplicity (prevents division by 0 error)
    // -No edges have multiplicity data (maxMult === minMult === null)
    if (maxMult != minMult) {
        edgeWidth = 3 + (((multiplicity - minMult)/(maxMult - minMult)) * 7);
    }
    var edgeID = sourceID + "->" + targetID;
    if (edgeObj['parent_cluster_id'] !== null) {
        cy.scratch("_ele2parent")[edgeID] = edgeObj['parent_cluster_id'];
    }
    if (sourceID === targetID) {
        // It's a self-directed edge; don't bother parsing ctrl pt
        // info, just render it as a bezier edge and be done with it
        cy.add({
            classes: "basicbezier",
            data: {id: edgeID, source: sourceID, target: targetID,
                   thickness: edgeWidth, mult: multiplicity}
        });
        return;
    }
    var srcPos = node2pos[sourceID];
    var tgtPos = node2pos[targetID];
    var srcSinkDist = distance(srcPos, tgtPos);
    var ctrlPts = ctrlPtStrToList(edgeObj['control_point_string'],
            [boundingboxObject['boundingbox_x'],
             boundingboxObject['boundingbox_y']]);
    var ctrlPtLen = edgeObj['control_point_count'];
    var nonzero = false;
    var ctrlPtDists = "";
    var ctrlPtWeights = "";
    var currPt, dsp, dtp, w, ws, wt, nonzero;
    for (var p = 0; p < ctrlPtLen; p++) {
        currPt = ctrlPts[p];
        // TODO inefficiency here -- rework pointToLineDistance.
        var d = -pointToLineDistance(currPt,
            {x: srcPos[0], y: srcPos[1]}, {x: tgtPos[0], y: tgtPos[1]});
        dsp = distance(currPt, srcPos);
        dtp = distance(currPt, tgtPos);
        // By the pythagorean thm., the interior of the square root
        // below should always be positive -- the hypotenuse must
        // always be greater than both of the other sides of a right
        // triangle.
        // However, due to Javascript's lovely (...)
        // type system, rounding errors can cause the hypotenuse (dsp
        // or dtp)
        // be represented as slightly less than d. So, to account for
        // these cases, we just take the abs. value of the sqrt body.
        // NOTE that ws = distance on line to source;
        //           wt = distance on line to target
        ws = Math.sqrt(Math.abs(Math.pow(dsp, 2) - Math.pow(d, 2)));
        wt = Math.sqrt(Math.abs(Math.pow(dtp, 2) - Math.pow(d, 2)));
        // Get the weight of the control point on the line between
        // source and sink oriented properly -- if the control point is
        // "behind" the source node, we make it negative, and if the
        // point is "past" the sink node, we make it > 1. Everything in
        // between the source and sink falls within [0, 1] inclusive.
        if (wt > srcSinkDist && wt > ws) {
            // The ctrl. pt. is "behind" the source node
            w = -ws / srcSinkDist;
        }
        else {
            // The ctrl. pt. is anywhere past the source node
            w = ws / srcSinkDist;
        }
        // If we detect all of the control points of an edge are less
        // than some epsilon value, we just render the edge as a normal
        // bezier (which defaults to a straight line).
        if (Math.abs(d) > CTRL_PT_DIST_EPSILON) {
            nonzero = true;
        }
        // Control points with a weight of 0 (as the first ctrl pt)
        // or a weight of 1 (as the last ctrl pt) aren't valid due
        // to implicit points already "existing there."
        // (See https://github.com/cytoscape/cytoscape.js/issues/1451)
        // This preemptively rectifies such control points.
        if (p === 0 && w === 0.0) {
            w = 0.01;
        }
        else if (p === (ctrlPtLen - 1) && w === 1.0) {
            w = 0.99;
        }
        ctrlPtDists += d.toFixed(2) + " ";
        ctrlPtWeights += w.toFixed(2) + " ";
    }
    ctrlPtDists = ctrlPtDists.trim();
    ctrlPtWeights = ctrlPtWeights.trim();
    if (nonzero) {
        // The control points should (hopefully) be valid
        cy.add({
            classes: "unbundledbezier",
            data: {id: edgeID, source: sourceID,
                   target: targetID, cpd: ctrlPtDists,
                   cpw: ctrlPtWeights, thickness: edgeWidth,
                   mult: multiplicity}
        });
    }
    else {
        // The control point distances are small enough that
        // we can just represent this as a straight bezier curve
      cy.add({
          classes: "basicbezier",
          data: {id: edgeID, source: sourceID, target: targetID,
                 thickness: edgeWidth, mult: multiplicity}
      });
    }
}

/* Given two points, each in the form [x, y], returns the distance between
 * the points obtained using d = sqrt((x2 - x1)^2 + (y2 - y1)^2).
 * e.g. distance([1, 2], [3, 4]) = sqrt((3 - 1)^2 + (4 - 2)^2) = sqrt(8)
 */
function distance(point1, point2) {
    return Math.sqrt(
              Math.pow(point2[0] - point1[0], 2)
            + Math.pow(point2[1] - point1[1], 2)
    );
}

/* Given a line that passes through two Nodes -- lNode1 and lNode2
 * -- this function returns the perpendicular distance from a point to the
 * line.
 */
function pointToLineDistance(point, lNode1, lNode2) {
    var lDist = distance([lNode1.x, lNode1.y], [lNode2.x, lNode2.y]);
    if (lDist === 0) {
        return 0;
    }
    var ydelta = lNode2.y - lNode1.y;
    var xdelta = lNode2.x - lNode1.x;
    var consts = (lNode2.x * lNode1.y) - (lNode2.y * lNode1.x);
    var numer = (ydelta * point[0]) - (xdelta * point[1]) + consts;
    return numer / lDist;
}
