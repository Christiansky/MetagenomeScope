"use strict";

/* Takes as input a .db file (generated by collate.py).
 * Using Cytoscape.js' batch controls, adds corresponding
 * nodes, edges, and clusters of nodes and edges to the
 * graph instance.
 */

// How many bytes to read at once from a .agp file
// For now, we set this to 1 MiB. The maximum Blob size in most browsers is
// around 500 - 600 MiB, so this should be well within that range.
// (We want to strike a balance between a small Blob size -- which causes lots
// of reading operations to be done, which takes a lot of time -- and a huge
// Blob size, which can potentially run out of memory, causing the read
// operation to fail.)
const BLOB_SIZE = 1048576;

// Various coordinates that are used to define polygon node shapes in
// Cytoscape.js (see their documentation for the format specs of these
// coordinates).
// The suffix indicates the directionality for which the polygon should be
// used. LEFTRIGHT means that the polygon should be used for either the default
// direction (LEFT, ->) or its opposite (RIGHT, <-); UPDOWN has similar
// meaning.
const FRAYED_ROPE_LEFTRIGHTDIR = "-1 -1 0 -0.5 1 -1 1 1 0 0.5 -1 1";
const FRAYED_ROPE_UPDOWNDIR =    "1 -1 0.5 0 1 1 -1 1 -0.5 0 -1 -1";
const BUBBLE_LEFTRIGHTDIR =      "-1 0 -0.5 -1 0.5 -1 1 0 0.5 1 -0.5 1";
const BUBBLE_UPDOWNDIR =         "-1 -0.5 0 -1 1 -0.5 1 0.5 0 1 -1 0.5";
const NODE_LEFTDIR =             "1 1 -0.23587 1 -1 0 -0.23587 -1 1 -1";
const NODE_RIGHTDIR =            "-1 1 0.23587 1 1 0 0.23587 -1 -1 -1";
const NODE_UPDIR =               "-1 1 -1 -0.23587 0 -1 1 -0.23587 1 1";
const NODE_DOWNDIR =             "-1 -1 -1 0.23587 0 1 1 0.23587 1 -1";
const SQUARE_COORDS =            "-1 -1 -1 1 1 1 1 -1";

// Approximate conversion factor from inches (the unit used by GraphViz for
// node width/height measurements) to pixels. TODO, we might want to
// consider node size more closely to see how accurate we can get it?
// Also -- maybe multiply coordinates by this, to get things worked out?
// 72 ppi?
const INCHES_TO_PIXELS = 54;

// Anything less than this constant will be considered a "straight" control
// point distance. This way we can approximate simple B-splines with straight
// bezier curves (which are cheaper and easier to draw).
const CTRL_PT_DIST_EPSILON = 1.00;
// Edge thickness stuff, as will be rendered by Cytoscape.js
// Used in tandem with the "thickness" percentage associated with each edge in
// the input .db file to scale edges' displayed "weight" accordingly
const MAX_EDGE_THICKNESS = 7;
const MIN_EDGE_THICKNESS = 3;
// We just calculate this here to save on the costs of calculating it |edges|
// times during drawing:
const EDGE_THICKNESS_RANGE = MAX_EDGE_THICKNESS - MIN_EDGE_THICKNESS;

// Misc. global variables we use to get certain functionality
// In degrees CCW from the default up->down direction
var PREV_ROTATION;
var CURR_ROTATION;
// Booleans for whether or not to use certain performance options
var HIDE_EDGES_ON_VIEWPORT = false;
var TEXTURE_ON_VIEWPORT = false;
// A reference to the current SQL.Database object from which we obtain the
// graph's layout and biological data
var CURR_DB = null;
// Filetype of the assembly; used for determining bp vs. nt for nodes
var ASM_FILETYPE;
// FIlename of the currently loaded .db file
var DB_FILENAME;
// Total number of nodes and edges in the current asm graph
var ASM_NODE_COUNT = 0;
var ASM_EDGE_COUNT = 0;
var CURR_NE = 0;
var TOTAL_NE = 0;
// How often (e.g. after how many nodes/half-edges) we update the progress
// bar with its new value. Will be set in drawComponent() for the current
// component being drawn, taking into account PROGRESSBAR_FREQ_PERCENT.
// Higher values of this mean less timeouts are used to update the
// progress bar, which means the graph is loaded somewhat faster,
// while smaller values of this mean more timeouts are used (i.e.
// slower graph loading) but choppier progress bar progress occurs.
var PROGRESSBAR_FREQ;
// PROGRESSBAR_FREQ = Math.floor(PROGRESSBAR_FREQ_PERCENT * SIZE), where
// SIZE = (number of nodes to be drawn) + 0.5*(number of edges to be drawn)
const PROGRESSBAR_FREQ_PERCENT = 0.05;

// Cytoscape.js graph instance
var cy = null;
// Numbers of selected elements, and collections of those selected elements.
var SELECTED_NODE_COUNT = 0;
var SELECTED_EDGE_COUNT = 0;
var SELECTED_CLUSTER_COUNT = 0;
var SELECTED_NODES = null;
var SELECTED_EDGES = null;
var SELECTED_CLUSTERS = null;
// Collection of removed edges (due to a minimum bundle size threshold).
var REMOVED_EDGES = null;
var PREV_EDGE_WEIGHT_THRESHOLD = null;
// Mapping of scaffold ID to labels of nodes contained in it, as a list. Used
// when highlighting nodes contained within a scaffold.
var SCAFFOLDID2NODELABELS = {};
// Used to indicate whether or not the current component has scaffolds added
// from the AGP file -- this, in turn, is used to determine what text to
// display to the user in the "View Scaffolds" area.
var COMPONENT_HAS_SCAFFOLDS = false;
// Used in determining which scaffolds are in the component.
var COMPONENT_NODE_LABELS = [];

// HTML snippets used while auto-creating info tables about selected elements
const TD_CLOSE = "</td>";
const TD_START = "<td>";
// Regular expression we use when matching integers.
var INTEGER_RE = /^\d+$/;

if (!(window.File && window.FileReader)) {
	alert("Your browser does not support the HTML5 File APIs. " +
          "You will not be able to upload any .db files, although " +
          "you can still try out any available demo .db files.");
}

// Initializes the Cytoscape.js graph instance.
// Takes as two arguments the polygon-point strings used for non-RC nodes
// (invhousePolygonPts) and for RC nodes (housePolygonPts).
function initGraph() {
    cy = cytoscape({
        container: document.getElementById("cy"),
        layout: {
            // We parse GraphViz' generated xdot files to copy the layout
            // provided by GraphViz. To manually specify node positions, we
            // use the "preset" Cytoscape.js layout.
            name: 'preset'
        },
        // We set minZoom based on the zoom level obtained by cy.fit().
        // maxZoom, however, is defined based on the zoom level of zooming to
        // fit around a single node -- which usually has an upper bound of 9 or
        // so, based on some tests. (Hence why we just set maxZoom here.)
        maxZoom: 9,
        // (sometimes slight) performance improvements
        pixelRatio: 1.0,
        hideEdgesOnViewport: HIDE_EDGES_ON_VIEWPORT,
        textureOnViewport: TEXTURE_ON_VIEWPORT,
        // options we use to prevent user from messing with the graph before
        // it's been fully drawn
        userPanningEnabled: false,
        userZoomingEnabled: false,
        boxSelectionEnabled: false,
        autounselectify: true,
        autoungrabify: true,
        style: [
            {
                selector: 'node',
                style: {
                    width: 'data(w)',
                    height: 'data(h)'
                }
            },
            // The following few classes are used to set properties of
            // compound nodes (analogous to clusters in GraphViz) 
            {
                selector: 'node.cluster',
                style: {
                    'background-opacity': 0.65,
                    'shape': 'square',
                    'compound-sizing-wrt-labels': 'exclude',
                    'padding-top': 0,
                    'padding-right': 0,
                    'padding-left': 0,
                    'padding-bottom': 0
                }
            },
            {
                // Give collapsed clusters a number indicating child count
                selector: 'node.cluster[?isCollapsed]',
                style: {
                    'min-zoomed-font-size': 12,
                    'font-size': 48,
                    'label': 'data(interiorNodeCount)',
                    'text-valign': 'center',
                    'font-weight': 'bold',
                }
            },
            {
                selector: 'node.R',
                style: {
                    // matches 'green2' in graphviz
                    // (but honestly I just picked what I considered to be
                    // the least visually offensive shade of green)
                    'background-color':'#00EE00',
                    shape: 'polygon'
                }
            },
            {
                selector: 'node.B',
                style: {
                    // matches 'cornflowerblue' in graphviz
                    'background-color':'#6495ED',
                    shape: 'polygon'
                }
            },
            {
                selector: 'node.B.leftrightdir',
                style: {
                    'shape-polygon-points': BUBBLE_LEFTRIGHTDIR
                }
            },
            {
                selector: 'node.B.updowndir',
                style: {
                    'shape-polygon-points': BUBBLE_UPDOWNDIR
                }
            },
            {
                selector: 'node.R.leftrightdir',
                style: {
                    'shape-polygon-points': FRAYED_ROPE_LEFTRIGHTDIR
                }
            },
            {
                selector: 'node.R.updowndir',
                style: {
                    'shape-polygon-points': FRAYED_ROPE_UPDOWNDIR
                }
            },
            {
                selector: 'node.C',
                style: {
                    // matches 'salmon' in graphviz
                    'background-color':'#FA8072'
                }
            },
            {
                selector: 'node.Y',
                style: {
                    // matches 'darkgoldenrod1' in graphviz
                    'background-color':'#FFB90F',
                    'shape': 'ellipse'
                }
            },
            {
                selector: 'node.bb_enforcing',
                style: {
                    // Make these nodes invisible
                    'background-opacity': 0,
                    // A width/height of zero just results in Cytoscape.js not
                    // drawing these nodes -- hence a width/height of one
                    width: 1,
                    height: 1
                }
            },
            {
                selector: 'node.noncluster',
                style: {
                    label: 'data(label)',
                    // rendering text is computationally expensive, so if
                    // we're zoomed out so much that the text would be
                    // illegible (or hard-to-read, at least) then don't
                    // render the text.
                    'min-zoomed-font-size': 12,
                    shape: 'polygon',
                    'background-color': 'data(bg_color)'
                }
            },
            {
                selector: 'node.noncluster.updir',
                style: {
                    'shape-polygon-points': NODE_UPDIR
                }
            },
            {
                selector: 'node.noncluster.downdir',
                style: {
                    'shape-polygon-points': NODE_DOWNDIR
                }
            },
            {
                selector: 'node.noncluster.leftdir',
                style: {
                    'shape-polygon-points': NODE_LEFTDIR
                }
            },
            {
                selector: 'node.noncluster.rightdir',
                style: {
                    'shape-polygon-points': NODE_RIGHTDIR
                }
            },
            {
                selector: 'node.noncluster:selected',
                style: {
                    // NOTE I liked using a border for indicating selected
                    // nodes, but it interfered with unbundled-bezier edges
                    // occasionally. So we just darken selected nodes instead.
                    //'border-color': '#000',
                    //'border-opacity': 1,
                    //'border-width': 5
                    'background-blacken': 0.5
                }
            },
            {
                selector: 'edge:selected',
                style: {
                    'line-color': '#000',
                    'source-arrow-color': '#000',
                    'target-arrow-color': '#000',
                    'mid-source-arrow-color': '#000',
                    'mid-target-arrow-color': '#000'
                }
            },
            {
                selector: 'node.cluster:selected',
                style: {
                    'border-width': 5,
                    'border-color': '#000'
                }
            },
            {
                selector: 'edge',
                style: {
                    'target-arrow-shape': 'triangle',
                    'width': 'data(thickness)'
                }
            },
            {
                // Used for edges that were assigned valid (i.e. not
                // just a straight line or self-directed edge)
                // cpd/cpw properties from the xdot file.
                selector: 'edge.unbundledbezier',
                style: {
                    'curve-style': 'unbundled-bezier',
                    'control-point-distances': 'data(cpd)',
                    'control-point-weights': 'data(cpw)',
                    'edge-distances': 'node-position'
                }
            },
            {
                // Used for:
                //  -Self-directed edges
                //  -Lines that are determined upon parsing the xdot file to
                //   be sufficiently close to a straight line
                //  -Temporary edges, for which we have no control point
                //   data (i.e. any edges directly from/to compound nodes
                //   during the collapsing process)
                selector: 'edge.basicbezier',
                style: {
                    'curve-style': 'bezier'
                }
            }
        ]
    });
}

/* Given a cluster, either collapses it (if already uncollapsed) or
 * uncollapses it (if already collapsed).
 */
function toggleCluster(cluster) {
    cy.startBatch();
    if (cluster.data("isCollapsed")) {
        uncollapseCluster(cluster);
    }
    else {
        collapseCluster(cluster);
    }
    cy.endBatch();
}

/* Collapses a given single cluster, making use of the
 * cluster's actual and canonical exterior edge data.
 * 
 * NOTE that this can result in the presence of codirected edges, if a
 * single node connects to multiple edges within the cluster (e.g. a
 * node has two outgoing edges, to both starting nodes of a frayed rope).
 */
function collapseCluster(cluster, moveMap) {
    var children = cluster.children();
    // For each edge with a target in the compound node...
    for (var incomingEdgeID in cluster.data("incomingEdgeMap")) {
        var oldEdge = cy.getElementById(incomingEdgeID);
        oldEdge.removeClass("unbundledbezier");
        oldEdge.addClass("basicbezier");
        oldEdge.move({target: cluster.id()});
    }
    // For each edge with a source in the compound node...
    for (var outgoingEdgeID in cluster.data("outgoingEdgeMap")) {
        var oldEdge = cy.getElementById(outgoingEdgeID);
        oldEdge.removeClass("unbundledbezier");
        oldEdge.addClass("basicbezier");
        oldEdge.move({source: cluster.id()});
    }
    cluster.data("isCollapsed", true);
    // Update list of locally collapsed nodes (useful for global toggling)
    cy.scratch("_collapsed", cy.scratch("_collapsed").union(cluster));
    cy.scratch("_uncollapsed", cy.scratch("_uncollapsed").difference(cluster));
    if (cy.scratch("_uncollapsed").empty()) {
        if ($("#collapseButtonText").text()[0] === 'C') {
            changeCollapseButton(true);
        }
    }
    // Unselect the elements before removing them (fixes #158 on GitHub)
    cluster.scratch("_interiorEles").unselect();
    // "Remove" the elements (they can be added back to the graph upon
    // uncollapsing this cluster, of course)
    cluster.scratch("_interiorEles").remove();
}

/* Uncollapses a given single cluster, making use of the cluster's actual
 * and canonical exterior edge data.
 */
function uncollapseCluster(cluster) {
    // Restore child nodes + interior edges
    cluster.scratch("_interiorEles").restore();
    // "Reset" edges to their original target/source within the cluster
    for (var incomingEdgeID in cluster.data("incomingEdgeMap")) {
        if (REMOVED_EDGES.is("[id=\"" + incomingEdgeID + "\"]")) {
            // The edge has probably been removed from the graph due to 
            // the edge weight thing -- ignore it
            continue;
        }
        var newTgt = cluster.data("incomingEdgeMap")[incomingEdgeID][1];
        var oldEdge = cy.getElementById(incomingEdgeID);
        // If the edge isn't connected to another cluster, and the edge
        // wasn't a basicbezier to start off with (i.e. it has control point
        // data), then change its classes to update its style.
        if (!oldEdge.source().hasClass("cluster") && oldEdge.data("cpd")) {
            if (!oldEdge.hasClass("reducededge")) {
                oldEdge.removeClass("basicbezier");
                oldEdge.addClass("unbundledbezier");
            }
        }
        oldEdge.move({target: newTgt});
    }
    for (var outgoingEdgeID in cluster.data("outgoingEdgeMap")) {
        if (REMOVED_EDGES.is("[id=\"" + outgoingEdgeID + "\"]")) {
            continue;
        }
        var newSrc = cluster.data("outgoingEdgeMap")[outgoingEdgeID][0];
        var oldEdge = cy.getElementById(outgoingEdgeID);
        if (!oldEdge.target().hasClass("cluster") && oldEdge.data("cpd")) {
            if (!oldEdge.hasClass("reducededge")) {
                oldEdge.removeClass("basicbezier");
                oldEdge.addClass("unbundledbezier");
            }
        }
        oldEdge.move({source: newSrc});
    }
    // Update local flag for collapsed status (useful for local toggling)
    cluster.data("isCollapsed", false);
    // Update list of locally collapsed nodes (useful for global toggling)
    cy.scratch("_collapsed", cy.scratch("_collapsed").difference(cluster));
    cy.scratch("_uncollapsed", cy.scratch("_uncollapsed").union(cluster));
    if (cy.scratch("_collapsed").empty()) {
        if ($("#collapseButtonText").text()[0] === 'U') {
            changeCollapseButton(false);
        }
    }
}

function addSelectedNodeInfo(ele) {
    var lengthEntry = ele.data("length").toLocaleString();
    if (ASM_FILETYPE === "GML") { // scaffolds
        lengthEntry += " bp";
    } else { // contigs in a "double graph"
        lengthEntry += " nt";
    }
    var eleID = ele.id();
    var nodeRowHTML = "<tr class='nonheader' id='row" + eleID + "'><td>" +
        eleID + TD_CLOSE;
    if (ASM_FILETYPE === "GML") {
        nodeRowHTML += TD_START + ele.data("label") + TD_CLOSE;
    }
    nodeRowHTML += TD_START + lengthEntry + TD_CLOSE;
    if (ASM_FILETYPE === "LastGraph") {
        // Round to two decimal places
        var depthEntry = Math.round(ele.data("depth") * 100) / 100 + "x";
        nodeRowHTML += TD_START + depthEntry + TD_CLOSE;
    }
    if (ASM_FILETYPE === "LastGraph" || ASM_FILETYPE === "GFA") {
        // Round to two decimal places
        // we multiply by 10000 because we're really multiplying by 100
        // twice: first to convert to a percentage, then to start the
        // rounding process
        var gcEntry = Math.round(ele.data("gc_content") * 10000) / 100 + "%";
        nodeRowHTML += TD_START + gcEntry + TD_CLOSE;
    }
    nodeRowHTML += "</tr>";
    $("#nodeInfoTable").append(nodeRowHTML);
    if (ele.data("hasDNA")) {
        enableButton("dnaExportButton");
    }
    else {
        disableButton("dnaExportButton");
    }
}

function addSelectedEdgeInfo(ele) {
    // returns an array of two elements: [source node id, target node id]
    var canonicalSourceAndTargetNode = ele.id().split("->");
    var edgeRowHTML = "<tr class='nonheader' id='row" +
        ele.id().replace(">", "") + "'><td>" +
        canonicalSourceAndTargetNode[0] + "</td><td>" +
        canonicalSourceAndTargetNode[1] + TD_CLOSE;
    if (ASM_FILETYPE === "GML" || ASM_FILETYPE === "LastGraph")
        edgeRowHTML += TD_START + ele.data("multiplicity") + TD_CLOSE;
    if (ASM_FILETYPE === "GML") {
        // Round mean and stdev entries both to two decimal places
        // These values are just estimates so this rounding is okay
        var meanEntry = Math.round(ele.data("mean") * 100) / 100;
        var stdevEntry = Math.round(ele.data("stdev") * 100) / 100;
        edgeRowHTML += TD_START + ele.data("orientation") + TD_CLOSE;
        edgeRowHTML += TD_START + meanEntry + TD_CLOSE;
        edgeRowHTML += TD_START + stdevEntry + TD_CLOSE;
    }
    edgeRowHTML += "</tr>";
    $("#edgeInfoTable").append(edgeRowHTML);
}

function addSelectedClusterInfo(ele) {
    var clustID = ele.data("id");
    var clustType;
    switch(clustID[0]) {
        case 'C': clustType = "Chain"; break;
        case 'Y': clustType = "Cyclic Chain"; break;
        case 'B': clustType = "Bubble"; break;
        case 'R': clustType = "Frayed Rope"; break;
        default: clustType = "Invalid (error)";
    }
    var clustSize = ele.data("interiorNodeCount");
    $("#clusterInfoTable").append("<tr class='nonheader' id='row" + ele.id() +
        "'><td>" + clustType + "</td><td>" + clustSize + "</td></tr>");
}

function removeSelectedEleInfo(ele) {
    // supports edges in old HTML versions, where > isn't allowed but - is
    $("#row" + ele.id().replace(">", "")).remove();
}

// Sets bindings for certain objects in the graph.
function setGraphBindings() {
    // Enable right-clicking to collapse/uncollapse compound nodes
    // We store added edges + removed nodes/edges in element-level
    // data, to facilitate only doing the work of determining which
    // elements to remove/etc. once (the first time around)
    cy.on('cxttap', 'node',
        function(e) {
            // Prevent collapsing being done during iterative drawing
            if (!$("#fitButton").hasClass("disabled")) {
                var node = e.cyTarget;
                if (node.hasClass("cluster")) {
                    toggleCluster(node);
                }
            }
        }
    );
    // I can't believe this actually works -- "this is too convenient
    // to actually work the first time I try it"...
    // This fixes all bad (invalid, so invisible) edges as soon as the
    // graph is first rendered, and then calls cy.offRender() to disable
    // the check for future rendering frames.
    // This ensures we call fixBadEdges() only after edges have been
    // displayed.
    // UPDATE: It looks like adding in the progress bar stuff, likely due to
    // use of timeouts, messes this up and prevents it from being run (?).
    // Or maybe fixBadEdges() is just run too soon? Anyway, moving
    // fixBadEdges() to after we call cy.fit() seems to work fine. So I'm
    // just going to do that.
    //cy.onRender(function() {
    //    fixBadEdges();
    //    cy.offRender();
    //});
    cy.on('select', 'node.noncluster, edge, node.cluster',
        function(e) {
            var x = e.cyTarget;
            if (x.hasClass("noncluster")) {
                SELECTED_NODE_COUNT += 1;
                SELECTED_NODES = SELECTED_NODES.union(x);
                $("#selectedNodeBadge").text(SELECTED_NODE_COUNT);
                addSelectedNodeInfo(x);
            } else if (x.isEdge()) {
                SELECTED_EDGE_COUNT += 1;
                SELECTED_EDGES = SELECTED_EDGES.union(x);
                $("#selectedEdgeBadge").text(SELECTED_EDGE_COUNT);
                addSelectedEdgeInfo(x);
            } else {
                SELECTED_CLUSTER_COUNT += 1;
                SELECTED_CLUSTERS = SELECTED_CLUSTERS.union(x);
                $("#selectedClusterBadge").text(SELECTED_CLUSTER_COUNT);
                addSelectedClusterInfo(x);
            }

            // If this is the first selected element, enable the
            // fitSelected button
            if (SELECTED_NODE_COUNT + SELECTED_EDGE_COUNT +
                    SELECTED_CLUSTER_COUNT === 1) {
                enableButton("fitSelectedButton");
            }
        }
    );
    cy.on('unselect', 'node.noncluster, edge, node.cluster',
        function(e) {
            var x = e.cyTarget;
            if (x.hasClass("noncluster")) {
                SELECTED_NODE_COUNT -= 1;
                SELECTED_NODES = SELECTED_NODES.difference(x);
                $("#selectedNodeBadge").text(SELECTED_NODE_COUNT);
                removeSelectedEleInfo(x);
                if (SELECTED_NODE_COUNT <= 0) {
                    disableButton("dnaExportButton");
                }
            } else if (x.isEdge()) {
                SELECTED_EDGE_COUNT -= 1;
                SELECTED_EDGES = SELECTED_EDGES.difference(x);
                $("#selectedEdgeBadge").text(SELECTED_EDGE_COUNT);
                removeSelectedEleInfo(x);
            } else {
                SELECTED_CLUSTER_COUNT -= 1;
                SELECTED_CLUSTERS = SELECTED_CLUSTERS.difference(x);
                $("#selectedClusterBadge").text(SELECTED_CLUSTER_COUNT);
                removeSelectedEleInfo(x);
            }

            // Not sure how we'd have a negative amount of selected
            // elements, but I figure we might as well cover our bases with
            // the <= 0 here :P
            if (SELECTED_NODE_COUNT + SELECTED_EDGE_COUNT +
                    SELECTED_CLUSTER_COUNT <= 0) {
                disableButton("fitSelectedButton");
            }
        }
    );
    // NOTE this binding works -- when dragging a node, if any of its edges
    // become invalid then this automatically switches them to basicbezier
    // edges. It works great on smaller graphs, but on huge graphs it can
    // make dragging nodes painfully slow.
    // We can optimize this a bit by caching the node incomer/
    // outgoer lists (see initNodeAdjacents()), but we'd have to keep
    // those updated through collapsing.
    // And even with cached lists, this is pretty slow. I guess we could
    // somehow reduce the granularity of this (e.g. only register something
    // every other frame?), though? But then we'd want to keep this
    // reliable, also.
    // Also, this removes edges' control point info, meaning once an edge
    // has been modified to a basicbezier it stays that way until the graph
    // is reloaded. Not sure if there's a way to check if the edge is valid
    // (and change it back to an unbundledbezier) without using the
    // Cytoscape.js renderer, so this would only make sense for graphs we
    // want to generally have as static.
    // (Maybe make this an option for the user?) TODO get this faster
    //cy.on('drag', 'node',
    //    function(e) {
    //        var node = e.cyTarget;
    //        fixBadEdges(node.data("adjacentEdges"));
    //    }
    //);
    // TODO look into getting this more efficient in the future, if possible
    // (Renders labels only on tapping elements; doesn't really save that
    // much time, and might actually be less efficient due to the time taken
    // to register a tap event)
    //cy.on('tapstart', 'node',
    //    function(e) {
    //        var node = e.cyTarget;
    //        console.log(node);
    //        cy.style().selector("[id = '" + node.id() + "']").style({
    //            'label': 'data(id)'
    //        }).update();
    //    }
    //);
}

/* Rotates a node's position and, if applicable, its polygon definition.
 * NOTE that position of a compound node only seems to matter when that
 * compound node is collapsed -- as soon as that compound node regains
 * one or more of its children, its position is neglected again.
 */
function rotateNode(i, n) {
    // Rotate node position
    var oldPt = n.position();
    var newPt = rotateCoordinate(oldPt['x'], oldPt['y']);
    n.position({x: newPt[0], y: newPt[1]});
    // Rotate node polygon definition
    // Doing this via classes is probably more efficient than giving each
    // node its own polygon points and rotating every node's polygon points
    // every time we rotate the graph
    if (n.hasClass("noncluster")) { 
        if (n.hasClass("updir")) n.removeClass("updir");
        else if (n.hasClass("downdir")) n.removeClass("downdir");
        else if (n.hasClass("leftdir")) n.removeClass("leftdir");
        else if (n.hasClass("rightdir")) n.removeClass("rightdir");
        n.addClass(getNodeCoordClass(n.data("house")));
    }
    // We don't bother rotating cyclic chains or chains' shapes, because those
    // shapes are directionless (whereas the bubble/frayed rope shapes have
    // directionality that it looks nice to change with the graph's rotation)
    else if (n.hasClass("B") || n.hasClass("R")) {
        if (n.hasClass("updowndir")) n.removeClass("updowndir");
        else if (n.hasClass("leftrightdir")) n.removeClass("leftrightdir");
        n.addClass(getClusterCoordClass());
    }
}

/* Modifies the graph's nodes and compound nodes "in situ" to move their
 * positions, along with rotating the control points of edges and the
 * definition of the house/invhouse node polygons.
 *
 * NOTE -- DISABLED ROTATION -- this function is unused at present
 */
function changeRotation() {
    PREV_ROTATION = CURR_ROTATION;
    CURR_ROTATION = parseInt($("#rotationButtonGroup .btn.active")
        .attr("value"));
    // We use the fit button's disabled status as a way to gauge whether
    // or not a graph is currently rendered; sorta hack-ish, but it works
    if (!$("#fitButton").hasClass("disabled")) {
        startIndeterminateProgressBar();
        window.setTimeout(function() {
            cy.startBatch();
            // This only rotates nodes that are not collapsed
            cy.filter('node').each(rotateNode);
            // Rotate nodes within currently collapsed node groups
            cy.scratch("_collapsed").each(function(i, n) {
                n.scratch("_interiorNodes").each(rotateNode);
            });
            cy.endBatch();
            cy.fit();
            finishProgressBar();
        }, 20);
    }
}

// If toUncollapseReady is false, changes the collapse button to say
// "Collapse all node groups" with a minus icon.
// If toUncollapseReady is true, changes the collapse button to say
// "Uncollapse all node groups" with a plus icon.
function changeCollapseButton(toUncollapseReady) {
    if (toUncollapseReady) {
        $("#collapseButtonText").text("Uncollapse all node groups");
        $("#collapseButtonIcon").removeClass("glyphicon-minus-sign").addClass(
            "glyphicon-plus-sign");
    }
    else {
        $("#collapseButtonText").text("Collapse all node groups");
        $("#collapseButtonIcon").removeClass("glyphicon-plus-sign").addClass(
            "glyphicon-minus-sign");
    }
}

// Clears the graph, to facilitate drawing another one.
// Assumes a graph has already been drawn (i.e. cy !== null)
function destroyGraph() {
    cy.destroy();
    changeCollapseButton(false);
}

/* Loads a .db file from the user's local system. */
function loadgraphfile() {
    var fr = new FileReader();
	var inputfile = document.getElementById('fileselector').files[0];
    if (inputfile === undefined) {
        alert("Please select a .db file to load.");
        return;
    }
    if (inputfile.name.toLowerCase().endsWith(".db")) {
        DB_FILENAME = inputfile.name;
        // Important -- remove old DB from memory if it exists
        closeDB();
        disableVolatileControls();
        $("#selectedNodeBadge").text(0);
        $("#selectedEdgeBadge").text(0);
        $("#selectedClusterBadge").text(0);
        disableButton("infoButton");
        $("#currComponentInfo").html(
            "No connected component has been drawn yet.");
        fr.onload = function(e) {
            if (e.target.readyState === FileReader.DONE) {
                loadDBfile(e.target.result);
            }
        }
        // set progress bar to indeterminate state while we close
        // the old DB (if needed) and load the new DB file.
        // This isn't really that helpful on computers/fast-ish
        // systems, but for large DB files or mobile devices
        // (basically, anywhere sql.js might run slowly) this is
        // useful.
        // worth noting: we store this function call in an anonymous
        // function in order to delay its execution to when the
        // timeout happens
        // (javascript can be strange sometimes)
        startIndeterminateProgressBar();
        window.setTimeout(function() {
            fr.readAsArrayBuffer(inputfile);
        }, 50);
    }
    else {
        alert("Please select a valid .db file to load.");
    }
}

/* Runs prep. tasks for loading the database file and parsing its assembly +
 * component information
 */
function loadDBfile(fileData) {
    // Temporarily store .db file as array of 8-bit unsigned ints
    var uIntArr = new Uint8Array(fileData);
    CURR_DB = new SQL.Database(uIntArr);
    parseDBcomponents();
    // Set progress bar to "finished" state
    finishProgressBar();
}

/* Retrieves assembly-wide and component information from the database,
 * adjusting UI elements to prepare for component drawing accordingly.
 */
function parseDBcomponents() {
    // Get assembly-wide info from the graph
    if (cy !== null) {
        destroyGraph();
    }
    var stmt = CURR_DB.prepare("SELECT * FROM assembly;");
    stmt.step();
    var graphInfo = stmt.getAsObject();
    stmt.free();
    var fnInfo = graphInfo["filename"];
    ASM_FILETYPE = graphInfo["filetype"];
    ASM_NODE_COUNT = graphInfo["node_count"];
    var nodeInfo = ASM_NODE_COUNT.toLocaleString();
    var bpCt = graphInfo["total_length"];
    var bpInfo = bpCt.toLocaleString() + " bp";
    ASM_EDGE_COUNT = graphInfo["edge_count"];
    TOTAL_NE = ASM_NODE_COUNT + ASM_EDGE_COUNT;
    var edgeInfo = ASM_EDGE_COUNT.toLocaleString();
    var compCt = graphInfo["component_count"];
    var compInfo = compCt.toLocaleString();
    // Record N50
    var n50 = graphInfo["n50"];
    var n50Info = n50.toLocaleString() + " bp";
    // Record Assembly G/C content (not available for GML files)
    var asmGC = graphInfo["gc_content"];
    if (ASM_FILETYPE === "LastGraph" || ASM_FILETYPE === "GFA") {
        // Round to two decimal places
        var asmGCInfo = Math.round((asmGC * 100) * 100) / 100 + "%";
        $("#asmGCEntry").text(asmGCInfo);
        $("#asmGCTH").removeClass("notviewable");
        $("#asmGCEntry").removeClass("notviewable");
    } else {
        $("#asmGCTH").addClass("notviewable");
        $("#asmGCEntry").addClass("notviewable");
    }
    // Adjust UI elements
    document.title = DB_FILENAME + " (" + fnInfo + ")";
    updateTextStatus("Loaded .db file for the assembly graph file " + fnInfo +
                        ".<br />You can draw a connected component using" +
                        " the \"Draw Connected Component\" button below.");
    $("#filenameEntry").text(fnInfo); 
    $("#filetypeEntry").text(ASM_FILETYPE);
    $("#nodeCtEntry").text(nodeInfo); 
    $("#totalBPLengthEntry").text(bpInfo); 
    $("#edgeCountEntry").text(edgeInfo);
    $("#connCmpCtEntry").text(compInfo);
    $("#n50Entry").text(n50Info);
    $("#componentselector").prop("max", compCt);
    $("#componentselector").prop("disabled", false);
    SCAFFOLDID2NODELABELS = {};
    $("#agpLoadedFileName").addClass("notviewable");
    $("#scaffoldInfoHeader").addClass("notviewable");
    $("#scaffoldListGroup").empty();
    COMPONENT_NODE_LABELS = [];
    enableButton("decrCompRankButton");
    enableButton("incrCompRankButton");
    enableButton("xmlFileselectButton");
    enableButton("fileselectButton");
    enableButton("loadDBbutton");
    enableButton("drawButton");
    enableButton("infoButton");
    enableButton("dir0");
    enableButton("dir90");
    enableButton("dir180");
    enableButton("dir270");
    $("#hideEdgesCheckbox").prop("disabled", false);
    $("#useTexturesCheckbox").prop("disabled", false);
    // Adjust selected info tables based on filetype (i.e. what info is
    // available)
    if (ASM_FILETYPE === "GML") {
        // Node info adjustments
        $("#nodeTH").prop("colspan", 3);
        $("#depthCol").addClass("notviewable");
        $("#labelCol").removeClass("notviewable");
        $("#gcContentCol").addClass("notviewable");
        // Edge info adjustments
        $("#edgeTH").prop("colspan", 6);
        $("#multiplicityCol").text("B. size");
        $("#multiplicityCol").removeClass("notviewable");
        $("#orientationCol").removeClass("notviewable");
        $("#meanCol").removeClass("notviewable");
        $("#stdevCol").removeClass("notviewable");
    }
    else if (ASM_FILETYPE === "LastGraph") {
        // Node info adjustments
        $("#nodeTH").prop("colspan", 4);
        $("#depthCol").removeClass("notviewable");
        $("#labelCol").addClass("notviewable");
        $("#gcContentCol").removeClass("notviewable");
        // Edge info adjustments
        $("#edgeTH").prop("colspan", 3);
        $("#multiplicityCol").text("Mult");
        $("#multiplicityCol").removeClass("notviewable");
        $("#orientationCol").addClass("notviewable");
        $("#meanCol").addClass("notviewable");
        $("#stdevCol").addClass("notviewable");
    }
    else if (ASM_FILETYPE === "GFA") {
        // Node info adjustments
        $("#nodeTH").prop("colspan", 3);
        $("#depthCol").addClass("notviewable");
        $("#labelCol").addClass("notviewable");
        $("#gcContentCol").removeClass("notviewable");
        // Edge info adjustments
        $("#edgeTH").prop("colspan", 2);
        $("#multiplicityCol").addClass("notviewable");
        $("#orientationCol").addClass("notviewable");
        $("#meanCol").addClass("notviewable");
        $("#stdevCol").addClass("notviewable");
    }
}

/* Enables a disabled <button> element that is currently disabled: that is,
 * it has the disabled class (which covers Bootstrap styling) and has the
 * disabled="disabled" property.
 */
function enableButton(buttonID) {
    $("#" + buttonID).removeClass("disabled");
    $("#" + buttonID).prop("disabled", false);
}

/* Disables an enabled <button> element. */
function disableButton(buttonID) {
    $("#" + buttonID).addClass("disabled");
    $("#" + buttonID).prop("disabled", true);
}

/* Disables some "volatile" controls in the graph. Should be used when doing
 * any sort of operation, I guess. */
function disableVolatileControls() {
    $("#hideEdgesCheckbox").prop("disabled", true);
    $("#useTexturesCheckbox").prop("disabled", true);
    $("#componentselector").prop("disabled", true);
    disableButton("decrCompRankButton");
    disableButton("incrCompRankButton");
    disableButton("fileselectButton");
    disableButton("loadDBbutton");
    disableButton("xmlFileselectButton");
    disableButton("drawButton");
    $("#searchInput").prop("disabled", true);
    $("#layoutInput").prop("disabled", true);
    $("#cullEdgesInput").prop("disabled", true);
    $("#cullEdgesInput").val("0"); // reset to avoid confusion
    disableButton("cullEdgesButton");
    disableButton("reduceEdgesButton");
    disableButton("layoutButton");
    disableButton("scaffoldFileselectButton");
    disableButton("startFinishingButton");
    disableButton("endFinishingButton");
    disableButton("searchButton");
    disableButton("collapseButton");
    disableButton("fitSelectedButton");
    disableButton("fitButton");
    disableButton("exportImageButton");
    disableButton("dir0");
    disableButton("dir90");
    disableButton("dir180");
    disableButton("dir270");
    disableButton("pngOption");
    disableButton("jpgOption");
    clearSelectedInfo();
    disableButton("dnaExportButton");
}

function updateTextStatus(text) {
    $("#textStatus").html(text);
}

function toggleHEV() {
    HIDE_EDGES_ON_VIEWPORT = !HIDE_EDGES_ON_VIEWPORT;
}
function toggleUTV() {
    TEXTURE_ON_VIEWPORT = !TEXTURE_ON_VIEWPORT;
}

/* Returns null if the value indicated by the string is not an integer (that
 * is, it matches the INTEGER_RE regex).
 * Returns -1 if it is an integer but is less than the min component rank
 * (using the min property of #componentselector in the DOM as a reference).
 * Returns 1 if it is an integer but is greater than the max component rank
 * (using the max property of #componentselector in the DOM as a reference).
 * Returns 0 if it is an integer and is within the range [min rank, max rank].
 *
 * We use this instead of just parseInt() because parseInt is (IMO) too
 * lenient when parsing integer values from strings, which can cause confusion
 * for users (e.g. a user enters in "2c" as a connected component and
 * component 2 is drawn, leading the user to somehow think that "2c" is a valid
 * connected component size rank).
 */
function compRankValidity(strVal) {
    if (strVal.match(INTEGER_RE) === null) return null;
    var intVal = parseInt(strVal);
    if (intVal < parseInt($("#componentselector").prop("min"))) return -1;
    if (intVal > parseInt($("#componentselector").prop("max"))) return 1;
    return 0;
}

/* Decrements the size rank of the component selector by 1. If the current
 * value of the component selector is not an integer, then the size rank is set
 * to the minimum size rank; if the current value is an integer that is greater
 * than the maximum size rank, then the size rank is set to the maximum size
 * rank.
 *
 * Also, if the size rank is equal to the minimum size rank, nothing happens.
 */
function decrCompRank() {
    var currRank = $("#componentselector").val();
    var minRank = parseInt($("#componentselector").prop("min"));
    var validity = compRankValidity(currRank);
    if (validity === null || parseInt(currRank) < (minRank + 1)) {
        $("#componentselector").val(minRank);
    }
    else if (validity === 1) {
        $("#componentselector").val($("#componentselector").prop("max"));
    }
    else {
        $("#componentselector").val(parseInt(currRank) - 1);
    }
}

/* Increments the size rank of the component selector by 1. Same "limits" as
 * in the first paragraph of decrCompRank()'s comments.
 *
 * Also, if the size rank is equal to the maximum size rank, nothing happens.
 */
function incrCompRank() {
    var currRank = $("#componentselector").val();
    var maxRank = parseInt($("#componentselector").prop("max"));
    var validity = compRankValidity(currRank);
    if (validity === null || validity === -1) {
        $("#componentselector").val($("#componentselector").prop("min"));
    }
    else if (currRank > (maxRank - 1)) {
        $("#componentselector").val(maxRank);
    }
    else {
        $("#componentselector").val(parseInt(currRank) + 1);
    }
}

function startDrawComponent() {
    var currRank = $("#componentselector").val();
    if (compRankValidity(currRank) !== 0) {
        alert("Please enter a valid component rank using the input field.");
        return;
    }
    // if compRankValidity === 0, then currRank must represent just an
    // integer: so parseInt is fine to run on it
    updateTextStatus("Drawing clusters...");
    window.setTimeout(drawComponent(parseInt(currRank)), 0);
}

/* Draws the selected connected component in the .db file -- its nodes, its
 * edges, its clusters -- to the screen.
 */
function drawComponent(cmpRank) {
    disableVolatileControls();
    // Okay, we can draw this component!
    if (cy !== null) {
        // If we already have a graph instance, clear that graph before
        // initializing another one
        // This should have already been called in parseDBcomponents(),
        // but since you can draw multiple components for the same .db file
        // we include this here as well
        destroyGraph();
    }
    initGraph();
    setGraphBindings();
    var componentNodeCount = 0;
    var componentEdgeCount = 0;
    SELECTED_NODES = cy.collection();
    SELECTED_EDGES = cy.collection();
    SELECTED_CLUSTERS = cy.collection();
    $("#scaffoldListGroup").empty();
    // will be set to true if we find suitable scaffolds
    // the actual work of finding those scaffolds (if SCAFFOLDID2NODELABELS is
    // not empty, of course) is done in finishDrawComponent().
    COMPONENT_HAS_SCAFFOLDS = false;
    $("#scaffoldInfoHeader").addClass("notviewable");
    COMPONENT_NODE_LABELS = [];
    SELECTED_NODE_COUNT = 0;
    SELECTED_EDGE_COUNT = 0;
    SELECTED_CLUSTER_COUNT = 0;
    REMOVED_EDGES = cy.collection();
    $("#selectedNodeBadge").text(0);
    $("#selectedEdgeBadge").text(0);
    $("#selectedClusterBadge").text(0);
    PREV_ROTATION = 0;
    // NOTE -- DISABLED ROTATION -- to allow rotation uncomment below and
    // replace CURR_ROTATION = 90 line
    //CURR_ROTATION = parseInt($("#rotationButtonGroup .btn.active")
    //    .attr("value"));
    CURR_ROTATION = 90;
    cy.scratch("_collapsed", cy.collection());
    cy.scratch("_uncollapsed", cy.collection());
    cy.scratch("_ele2parent", {});
    // Now we render the nodes, edges, and clusters of this component.
    // But first we need to get the bounding box of this component.
    // Along with the component's total node count.
    var bbStmt = CURR_DB.prepare(
        "SELECT boundingbox_x, boundingbox_y, node_count, edge_count FROM components WHERE " +
        "size_rank = ? LIMIT 1", [cmpRank]);
    bbStmt.step();
    var fullObj = bbStmt.getAsObject();
    bbStmt.free();
    var bb = {'boundingbox_x': fullObj['boundingbox_x'],
              'boundingbox_y': fullObj['boundingbox_y']};
    var totalElementCount = fullObj['node_count'] +
        (0.5 * fullObj['edge_count']); 
    // here we scale PROGRESSBAR_FREQ to totalElementCount for the
    // component to be drawn (see top of file for reference)
    // As we draw other components later within the same session of the viewer
    // application, PROGRESSBAR_FREQ will be updated accordingly
    PROGRESSBAR_FREQ= Math.floor(PROGRESSBAR_FREQ_PERCENT * totalElementCount);
    // We need a fast way to associate node IDs with their x/y positions.
    // This is for calculating edge control point weight/distance.
    // And doing 2 DB queries (src + tgt) for each edge will take a lot of
    // time -- O(2|E|) time, specifically, with the only benefit of not
    // taking up a lot of space. So we go with the mapping solution -- it's
    // not particularly pretty, but it works alright.
    var node2pos = {};
    // We check to see if the component contains >= 1 cluster. If so, we
    // enable the collapse/uncollapse button; if not, we don't bother
    // enabling the button and keep it disabled because it'd be useless
    var clustersInComponent = false;
    cy.startBatch();
    var clustersStmt = CURR_DB.prepare(
        "SELECT * FROM clusters WHERE component_rank = ?", [cmpRank]);
    while (clustersStmt.step()) {
        clustersInComponent = true;
        renderClusterObject(clustersStmt.getAsObject(), bb);
    }
    clustersStmt.free();
    // Draw graph "iteratively" -- display all clusters.
    drawBoundingBoxEnforcingNodes(bb);
    cy.endBatch();
    cy.fit();
    updateTextStatus("Drawing nodes...");
    window.setTimeout(function() {
        /* I originally didn't have this wrapped in a timeout, but for some
         * reason a few clusters in the test BAMBUS E. coli assembly weren't
         * being rendered at the waiting point. It seemed some sort of race
         * condition was happening, and wrapping this block of code in a
         * timeout seems to solve the problem for iterative cluster drawing
         * (iterative node/edge drawing is fine, since those already use
         * timeouts to update the progress bar).
         */
        cy.startBatch();
        var nodesStmt = CURR_DB.prepare(
            "SELECT * FROM nodes WHERE component_rank = ?", [cmpRank]);
        CURR_NE = 0;
        drawComponentNodes(nodesStmt, bb, cmpRank, node2pos,
            clustersInComponent, componentNodeCount, componentEdgeCount,
            totalElementCount);
    }, 0);
}

function drawComponentNodes(nodesStmt, bb, cmpRank, node2pos,
        clustersInComponent, componentNodeCount, componentEdgeCount,
        totalElementCount) {
    var currNode;
    if (nodesStmt.step()) {
        currNode = nodesStmt.getAsObject();
        // Render the node object and save its position
        node2pos[currNode['id']] = renderNodeObject(currNode, bb);
        componentNodeCount += 1;
        CURR_NE += 1;
        if (CURR_NE % PROGRESSBAR_FREQ === 0) {
            updateProgressBar((CURR_NE / totalElementCount) * 100);
            window.setTimeout(function() {
                drawComponentNodes(nodesStmt, bb, cmpRank, node2pos,
                    clustersInComponent, componentNodeCount,
                    componentEdgeCount, totalElementCount);
            }, 0);
        }
        else {
            drawComponentNodes(nodesStmt, bb, cmpRank, node2pos,
                clustersInComponent, componentNodeCount, componentEdgeCount,
                totalElementCount);
        }
    }
    else {
        nodesStmt.free();
        // Second part of "iterative" graph drawing: draw all nodes
        // For what it's worth: This next line (endBatch()) actually draws all
        // nodes, giving the user the appearance of the progress bar slowing
        // down significantly at this point. Not sure if there's a way to
        // circumvent this?
        cy.endBatch();
        cy.fit();
        updateTextStatus("Drawing edges...");
        cy.startBatch();
        // NOTE that we intentionally only consider edges within this component
        // Multiplicity is an inherently relative measure, so outliers in other
        // components will just mess things up in the current component.
        var maxMult, minMult;
        var maxMultiplicityStmt = CURR_DB.prepare(
            "SELECT * FROM edges WHERE component_rank = ? " +
            "ORDER BY multiplicity DESC LIMIT 1", [cmpRank]);
        maxMultiplicityStmt.step();
        maxMult = maxMultiplicityStmt.getAsObject()['multiplicity'];
        maxMultiplicityStmt.free();
        // If the assembly doesn't have edge multiplicity data, don't bother
        // trying to find the minimum -- that'll also be null.
        if (maxMult !== null) {
            var minMultiplicityStmt = CURR_DB.prepare(
                "SELECT * FROM edges WHERE component_rank = ? " + 
                "ORDER BY multiplicity LIMIT 1", [cmpRank]);
            minMultiplicityStmt.step();
            minMult = minMultiplicityStmt.getAsObject()['multiplicity'];
            minMultiplicityStmt.free();
        }
        else {
            minMult = null;
        }
        var edgesStmt = CURR_DB.prepare(
            "SELECT * FROM edges WHERE component_rank = ?", [cmpRank]);
        drawComponentEdges(edgesStmt, bb, node2pos, maxMult, minMult, cmpRank,
            clustersInComponent, componentNodeCount, componentEdgeCount,
            totalElementCount);
    }
}

function drawComponentEdges(edgesStmt, bb, node2pos, maxMult, minMult, cmpRank,
        clustersInComponent, componentNodeCount, componentEdgeCount,
        totalElementCount) {
    if (edgesStmt.step()) {
        renderEdgeObject(edgesStmt.getAsObject(), node2pos,
            maxMult, minMult, bb, componentNodeCount, componentEdgeCount,
            totalElementCount);
        componentEdgeCount += 1;
        CURR_NE += 0.5;
        if (CURR_NE % PROGRESSBAR_FREQ === 0) {
            updateProgressBar((CURR_NE / totalElementCount) * 100);
            window.setTimeout(function() {
                drawComponentEdges(edgesStmt, bb, node2pos, maxMult, minMult,
                    cmpRank, clustersInComponent, componentNodeCount,
                    componentEdgeCount, totalElementCount);
            }, 0);
        }
        else {
            drawComponentEdges(edgesStmt, bb, node2pos, maxMult, minMult,
                cmpRank, clustersInComponent, componentNodeCount,
                componentEdgeCount, totalElementCount);
        }
    }
    else {
        edgesStmt.free();
        removeBoundingBoxEnforcingNodes(bb);
        finishDrawComponent(cmpRank, componentNodeCount, componentEdgeCount,
            clustersInComponent);
    }
}

function finishDrawComponent(cmpRank, componentNodeCount, componentEdgeCount,
        clustersInComponent) {
    var intro = "The ";
    var nodePercentage = (componentNodeCount / ASM_NODE_COUNT) * 100;
    var edgePercentage = (componentEdgeCount / ASM_EDGE_COUNT) * 100;
    var all_nodes_edges_modifier = "the";
    if ($("#filetypeEntry").text() !== "GML") {
        intro = "Including <strong>both positive and negative</strong>" +
            " nodes and edges, the ";
        nodePercentage /= 2;
        edgePercentage /= 2;
        all_nodes_edges_modifier = "all positive and negative";
    }
    // This is incredibly minor, but I always get annoyed at software that
    // doesn't use correct grammar for stuff like this nowadays :P
    var nodeNoun = (componentNodeCount === 1) ? "node" : "nodes";
    var edgeNoun = (componentEdgeCount === 1) ? "edge" : "edges";
    $("#currComponentInfo").html(intro + "current component (size rank "
       + cmpRank + ") has <strong>" + componentNodeCount + " " + nodeNoun
       + "</strong> and <strong>" + componentEdgeCount + " " + edgeNoun
       + "</strong>. This component contains <strong>"
       + nodePercentage.toFixed(2) + "% of " + all_nodes_edges_modifier
       + " nodes</strong> in the assembly and <strong>"
       + edgePercentage.toFixed(2) + "% of " + all_nodes_edges_modifier
       + " edges</strong> in the assembly.");
    // NOTE modified initClusters() to do cluster height after the fact.
    // This represents an inefficiency when parsing xdot files, although it
    // shouldn't really affect anything major.
    initClusters();
    cy.endBatch();
    cy.fit();
    // Set minZoom to whatever the zoom level when viewing the entire drawn
    // component at once (i.e. right now) is
    cy.minZoom(cy.zoom());
    fixBadEdges();
    updateTextStatus("Preparing interface...");
    window.setTimeout(function() {
        // If we have scaffold data still loaded for this assembly, use it
        // for the newly drawn connected component.
        if (isObjectNonempty(SCAFFOLDID2NODELABELS)) {
            updateScaffoldsInComponentList();
        }
        // At this point, all of the hard work has been done. All that's left
        // to do now is re-enable controls, enable graph interaction, etc.
        $("#componentselector").prop("disabled", false);
        enableButton("decrCompRankButton");
        enableButton("incrCompRankButton");
        enableButton("fileselectButton");
        enableButton("loadDBbutton");
        enableButton("xmlFileselectButton");
        enableButton("drawButton");
        $("#searchInput").prop("disabled", false);
        $("#layoutInput").prop("disabled", false);
        if (ASM_FILETYPE === "LastGraph" || ASM_FILETYPE === "GML") {
            // Only enable the edge culling features for graphs that have edge
            // weights (multiplicity or bundle size)
            $("#cullEdgesInput").prop("disabled", false);
            enableButton("cullEdgesButton");
        }
        if (componentEdgeCount > 0) {
            enableButton("reduceEdgesButton");
        }
        enableButton("layoutButton");
        enableButton("scaffoldFileselectButton");
        enableButton("startFinishingButton");
        enableButton("endFinishingButton");
        enableButton("searchButton");
        enableButton("fitButton");
        enableButton("exportImageButton");
        enableButton("dir0");
        enableButton("dir90");
        enableButton("dir180");
        enableButton("dir270");
        enableButton("pngOption");
        enableButton("jpgOption");
        $("#hideEdgesCheckbox").prop("disabled", false);
        $("#useTexturesCheckbox").prop("disabled", false);
        cy.userPanningEnabled(true);
        cy.userZoomingEnabled(true);
        cy.boxSelectionEnabled(true);
        cy.autounselectify(false);
        cy.autoungrabify(false);
        if (clustersInComponent) {
            enableButton("collapseButton");
        }
        else {
            disableButton("collapseButton");
        }
        updateTextStatus("&nbsp;");
        finishProgressBar();
    }, 0);
}

/* Returns true if the specified object is not empty, false otherwise.
 * (We assume that the object is just a normal "mapping." This is only really
 * intended to work for SCAFFOLDID2NODELABELS at present -- I can't guarantee
 * it'll work for other JavaScript objects.)
 */
function isObjectNonempty(object) {
    for (var k in object) {
        return true;
    }
    return false;
}

// TODO verify that this doesn't mess stuff up when you back out of and then
// return to the page. Also are memory leaks even a thing that we have
// to worry about in Javascript?????????
function closeDB() {
    if (CURR_DB !== null) {
        CURR_DB.close();
    }
}

function changeDropdownVal(arrowHTML) {
    $("#rotationDropdown").html(arrowHTML + " <span class='caret'></span>"); 
}

// Toggle visibility of the controls div.
function toggleControls() {
    $("#controls").toggleClass("notviewable");
    $("#cy").toggleClass("nosubsume");
    $("#cy").toggleClass("subsume");
    if (cy !== null) {
        cy.resize();
    }
}

function openFileSelectDialog() {
    $("#fsDialog").modal(); 
}

/* Loads a .db file using an XML HTTP Request. */
function loadajaxDB() {
    // Important -- remove old DB from memory if it exists
    closeDB();
    // usually we won't have the luxury of ID === filename, but this is a
    // demo so might as well
    $("#fsDialog").modal("hide");
    disableVolatileControls();
    $("#selectedNodeBadge").text(0);
    $("#selectedEdgeBadge").text(0);
    $("#selectedClusterBadge").text(0);
    disableButton("infoButton");
    $("#currComponentInfo").html(
        "No connected component has been drawn yet.");
    var filename = $("input[name=fs]:checked").attr('id');
    DB_FILENAME = filename;
    // jQuery doesn't support arraybuffer responses so we have to manually
    // use an XMLHttpRequest(), strange capitalization and all
    // Credit to this approach goes here, btw:
    // http://www.henryalgus.com/reading-binary-files-using-jquery-ajax/
    var xhr = new XMLHttpRequest();
    xhr.open("GET", filename, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = function(eve) {
        if (this.status === 200) {
            loadDBfile(this.response);
        }
    };
    startIndeterminateProgressBar();
    xhr.send();
}

// Given percentage lies within [0, 100]
function updateProgressBar(percentage) {
    $(".progress-bar").css("width", percentage + "%");
    $(".progress-bar").attr("aria-valuenow", percentage);
}

function finishProgressBar() {
    // We call updateProgressBar since, depending on the progress bar update
    // frequency in the process that was ongoing before finishProgressBar() is
    // called, the progress bar could be at a value less than 100%. So we call
    // updateProgressBar(100) as a failsafe to make sure the progress bar
    // always ends up at 100%, regardless of the update frequency.
    updateProgressBar(100);
    if (!$(".progress-bar").hasClass("notransitions")) {
        $(".progress-bar").addClass("notransitions")
    }
    if ($(".progress-bar").hasClass("progress-bar-striped")) {
        $(".progress-bar").removeClass("progress-bar-striped");
    }
    if ($(".progress-bar").hasClass("active")) {
        $(".progress-bar").removeClass("active");
    }
}

/* Assumes the progress bar is not already indeterminate. */
function startIndeterminateProgressBar() {
    $(".progress-bar").css("width", "100%");
    $(".progress-bar").removeClass("notransitions");
    $(".progress-bar").addClass("active");
    $(".progress-bar").addClass("progress-bar-striped");
}

/* Pops up a dialog displaying assembly information. */
function displayInfo() {
    $("#infoDialog").modal();
}

/* eleType can be one of {"node", "edge", "cluster"} */
function toggleEleInfo(eleType) {
    var openerID = "#" + eleType + "Opener";
    var infoDivID = "#" + eleType + "Info";
    if ($(openerID).hasClass("glyphicon-triangle-right")) {
        $(openerID).removeClass("glyphicon-triangle-right"); 
        $(openerID).addClass("glyphicon-triangle-bottom"); 
    }
    else { 
        $(openerID).removeClass("glyphicon-triangle-bottom"); 
        $(openerID).addClass("glyphicon-triangle-right"); 
    }
    $(infoDivID).toggleClass("notviewable");
}

function clearSelectedInfo() {
    $("#nodeInfoTable tr.nonheader").remove();
    $("#edgeInfoTable tr.nonheader").remove();
    $("#clusterInfoTable tr.nonheader").remove();
    disableButton("dnaExportButton");
    if ($("#nodeOpener").hasClass("glyphicon-triangle-bottom")) {
        toggleEleInfo('node');
    }
    if ($("#edgeOpener").hasClass("glyphicon-triangle-bottom")) {
        toggleEleInfo('edge');
    }
    if ($("#clusterOpener").hasClass("glyphicon-triangle-bottom")) {
        toggleEleInfo('cluster');
    }
}

/* Return a single string containing the DNA sequences of the selected
 * nodes, in FASTA format.
 */
function getSelectedNodeDNA() {
    // Get DNA sequences from database file, and append them to a string
    var dnaStmt;
    var dnaSeqs = "";
    var currDnaSeq;
    var seqIndex;
    var afterFirstSeqLine;
    SELECTED_NODES.each(function(i, e) {
        // TODO Is there any way to make this more efficient? Like, via
        // selecting multiple dnafwd values at once...?
        dnaStmt = CURR_DB.prepare("SELECT dnafwd FROM nodes WHERE id = ?",
            [e.id()]);
        dnaStmt.step();
        if (i > 0) {
            dnaSeqs += "\n";
        }
        dnaSeqs += ">NODE_" + e.id() + "\n";
        afterFirstSeqLine = false;
        currDnaSeq = dnaStmt.getAsObject()['dnafwd'];
        for (seqIndex = 0; seqIndex < currDnaSeq.length; seqIndex += 70) {
            if (afterFirstSeqLine) {
                dnaSeqs += "\n";
            }
            else {
                afterFirstSeqLine = true;
            }
            dnaSeqs += currDnaSeq.substring(seqIndex, seqIndex + 70);
        }
        dnaStmt.free();
    });
    return dnaSeqs;
}
 
/* Exports selected node DNA to a FASTA file via a data URI. */
function exportSelectedNodeDNA() {
    window.open(
        "data:text/FASTA;charset=utf-8;base64," +
        window.btoa(getSelectedNodeDNA()),
        "_blank"
    );
}

/* Fits the graph to all its elements if toSelected is false, and to only
 * selected elements if toSelected is true.
 */
function fitGraph(toSelected) {
    startIndeterminateProgressBar();
    window.setTimeout(
        function() {
            if (toSelected) {
                // Right now, we don't throw any sort of error here if
                // no elements are selected. This is because the fit-selected
                // button is only enabled when >= 1 elements are selected.
                cy.fit(
                    SELECTED_NODES.union(SELECTED_EDGES).union(
                        SELECTED_CLUSTERS)
                );
            } else {
                cy.fit();
            }
            finishProgressBar();
        }, 20
    );
}

/* Exports image of graph. */
function exportGraphView() {
    var imgType = $("#imgTypeButtonGroup .btn.active").attr("value");
    if (imgType === "PNG") {
        window.open(cy.png(), "_blank");
    }
    else {
        window.open(cy.jpg(), "_blank");
    }
}

/* Hides edges below a minimum edge weight (multiplicity or bundle size,
 * depending on the assembly graph that has been loaded).
 * This should only be called if the assembly graph that has been loaded has
 * edge weights as a property (e.g. LastGraph or Bambus 3 GML graphs).
 */
function cullEdges() {
    var strVal = $("#cullEdgesInput").val();
    // Check that the input is a nonnegative integer
    // (parseInt() is pretty lax)
    if (strVal.match(INTEGER_RE) === null) {
        alert("Please enter a valid minimum edge weight (a nonnegative " +
              "integer) using the input field.");
        return;
    }
    var threshold = parseInt(strVal);
    // Use PREV_EDGE_WEIGHT_THRESHOLD to prevent redundant operations being
    // done when the user double-clicks this button
    if (PREV_EDGE_WEIGHT_THRESHOLD !== threshold) {
        cy.startBatch();
        // Restore removed edges that would fit within a lowered threshold
        // Also, remove these edges from REMOVED_EDGES
        var restoredEdges = cy.collection();
        REMOVED_EDGES.each(
            function(i, e) {
                if (e.data("multiplicity") >= threshold) {
                    // If the edge points to/from a node within a collapsed
                    // cluster, then make the edge a basicbezier and move the
                    // edge to point to the cluster accordingly.
                    // TODO, consult point 2 on issue #161
                    if (e.source().removed()) {
                        e.removeClass("unbundledbezier");
                        e.addClass("basicbezier");
                        e.move({source: e.source().data("parent")});
                    }
                    if (e.target().removed()) {
                        e.removeClass("unbundledbezier");
                        e.addClass("basicbezier");
                        e.move({target: e.target().data("parent")});
                    }
                    e.restore();
                    restoredEdges = restoredEdges.union(e);
                }
            }
        );
        REMOVED_EDGES = REMOVED_EDGES.difference(restoredEdges);
        // Remove edges that have multiplicity less than the specified
        // threshold
        cy.$("edge").each(
            function(i, e) {
                var mult = e.data("multiplicity");
                if (mult !== null && mult < threshold) {
                    if (e.selected())
                        e.unselect();
                    REMOVED_EDGES = REMOVED_EDGES.union(e.remove());
                }
            }
        );
        cy.endBatch();
        PREV_EDGE_WEIGHT_THRESHOLD = threshold;
    }
}

function beginLoadAGPfile() {
    var sfr = new FileReader();
    // will be set to true if we find suitable scaffolds
    COMPONENT_HAS_SCAFFOLDS = false;
	var inputfile = document.getElementById('scaffoldFileSelector').files[0];
    if (inputfile === undefined) {
        alert("Please select an AGP file to load.");
        return;
    }
    if (inputfile.name.toLowerCase().endsWith(".agp")) {
        // The file is valid. We can load it.
        startIndeterminateProgressBar();
        SCAFFOLDID2NODELABELS = {};
        $("#scaffoldInfoHeader").addClass("notviewable");
        $("#scaffoldListGroup").empty();
        // Set some attributes of the FileReader object that we update while
        // reading the file.
        sfr.nextStartPosition = 0;
        sfr.partialLine = "";
        sfr.readingFinalBlob = false;
        // This is called after every Blob (manageably-sized chunk of the file)
        // is loaded via this FileReader object.
        sfr.onload = function(e) {
            if (e.target.readyState === FileReader.DONE) {
                var blobText = e.target.result;
                var blobLines = blobText.split("\n");
                // Newlines located at the very start or end of blobText will
                // cause .split() to add "" in those places, which makes
                // integrating sfr.partialLine with this a lot easier.
                // (As opposed to us having to manually check for newlines in
                // those places.)
                if (blobLines.length > 1) {
                    // Process first line, which may or may not include
                    // sfr.partialLine's contents (sfr.partialLine may be "",
                    // or blobLines[0] may be "").
                    integrateAGPline(sfr.partialLine + blobLines[0]);
                    sfr.partialLine = "";
                    // Process "intermediate" lines
                    for (var i = 1; i < blobLines.length - 1; i++) {
                        integrateAGPline(blobLines[i]);
                    }
                    // Process last line in the blob: if we know this is the
                    // last Blob we can read then we treat this last line as a
                    // complete line. Otherwise, we just store it in
                    // sfr.partialLine.
                    if (sfr.readingFinalBlob) {
                        integrateAGPline(blobLines[blobLines.length - 1]);
                    }
                    else {
                        sfr.partialLine = blobLines[blobLines.length - 1];
                    }
                }
                else if (blobLines.length === 1) {
                    // blobText doesn't contain any newlines
                    if (sfr.readingFinalBlob) {
                        integrateAGPline(sfr.partialLine + blobText);
                    }
                    else {
                        sfr.partialLine += blobText;
                    }
                }
                loadAGPfile(this, inputfile, this.nextStartPosition);
            }
        }
        loadAGPfile(sfr, inputfile, 0);
    }
    else {
        alert("Please select a valid AGP file to load.");
    }
}

/* Given a line of text (i.e. no newline characters are in the line), adds the
 * contig referenced in that line to the SCAFFOLDID2NODELABELS mapping. Also
 * adds the scaffold referenced in that line, if not already defined (i.e. this
 * is the first line we've called this function on that references that
 * scaffold).
 *
 * Saves contig/scaffold info for the entire assembly graph, not just the
 * current connected component. This will allow us to reuse the same mapping
 * for multiple connected components' visualizations.
 */
function integrateAGPline(lineText) {
    // Avoid processing empty lines (e.g. due to trailing newlines in files)
    // Also avoid processing comment lines (lines that start with #)
    if (lineText != "" && lineText[0] !== "#") {
        var lineColumns = lineText.split("\t");
        var scaffoldID = lineColumns[0];
        var contigLabel = lineColumns[5];
        // If the node ID has metadata, truncate it
        if (contigLabel.startsWith("NODE")) {
            contigLabel = "NODE_" + contigLabel.split("_")[1];
        }
        // Save scaffold node composition data for all scaffolds, not just
        // scaffolds pertinent to the current connected component
        if (SCAFFOLDID2NODELABELS[scaffoldID] === undefined) {
            SCAFFOLDID2NODELABELS[scaffoldID] = [contigLabel];
            // Check if this contig is in the current connected component and,
            // if so, add a list group item for its scaffold (since this is the
            // first time we're seeing this scaffold).
            // (We use COMPONENT_NODE_LABELS for this because running
            // cy.filter() repeatedly can get really slow.)
            if (COMPONENT_NODE_LABELS.indexOf(contigLabel) !== -1) {
                addScaffoldListGroupItem(scaffoldID);
            }
        }
        else {
            SCAFFOLDID2NODELABELS[scaffoldID].push(contigLabel);
        }
    }
}

/* Creates a list group item for a scaffold with the given ID.
 * (The ID should match up with a key in SCAFFOLDID2NODELABELS.)
 */
function addScaffoldListGroupItem(scaffoldID) {
    COMPONENT_HAS_SCAFFOLDS = true;
    // Add a list item for this scaffold
    $("#scaffoldListGroup").append(
        "<li class='list-group-item scaffold' " +
        "onclick='highlightScaffold(\"" + scaffoldID + "\");'>" +
        scaffoldID + "</li>");
}

/* Identifies scaffolds located in the current connected component (using the
 * keys to SCAFFOLDID2NODELABELS as a list of scaffolds to try) and, for those
 * scaffolds, calls addScaffoldListGroupItem().
 */
function updateScaffoldsInComponentList() {
    for (var s in SCAFFOLDID2NODELABELS) {
        // All nodes within a scaffold are in the same connected component, so
        // we can just use the first node in a scaffold as an indicator for
        // whether or not that scaffold is in the current connected component.
        // (This is pretty much the same way we do this when initially loading
        // scaffold data, as with integrateAGPline() above.)
        if (COMPONENT_NODE_LABELS.indexOf(SCAFFOLDID2NODELABELS[s][0]) !== -1){
            addScaffoldListGroupItem(s);
        }
    }
    updateScaffoldInfoHeader(false);
}

/* Recursively loads the AGP file using Blobs. (After the FileReader loads a
 * Blob, it calls this method for the next Blob.)
 *
 * fileReader and file should remain constant through the recursive loading
 * process, while filePosition will be updated as the file is loaded.
 * The initial call to loadAGPfile() should use filePosition = 0 (in order to
 * start reading the file from its 0th byte, i.e. its beginning).
 */
function loadAGPfile(fileReader, file, filePosition) {
    // Only get a Blob if it'd have some data in it
    if (filePosition <= file.size) {
        // In interval notation, the slice includes bytes in the range
        // [filePosition, endPosition). That is, the endPosition byte is not
        // included in currentBlob.
        var endPosition = filePosition + BLOB_SIZE;
        var currentBlob = file.slice(filePosition, endPosition);
        if (endPosition > file.size) {
            fileReader.readingFinalBlob = true;
        }
        fileReader.nextStartPosition = endPosition;
        fileReader.readAsText(currentBlob);
    }
    else {
        updateScaffoldInfoHeader(true);
    }
}

/* Updates scaffoldInfoHeader depending on whether or not scaffolds were
 * identified in the current connected component.
 *
 * If agpFileJustLoaded is true, then the agpLoadedFileName will be updated,
 * scaffoldFileSelector will have its value cleared (to allow for the same
 * AGP file to be loaded again if necessary) finishProgressBar() will be
 * called. Therefore, agpFileJustLoaded should only be set to true when this
 * function is being called after an AGP file has just been loaded.
 */
function updateScaffoldInfoHeader(agpFileJustLoaded) {
    if (COMPONENT_HAS_SCAFFOLDS) {
        $("#scaffoldInfoHeader").html("Scaffolds in Connected Component<br/>" +
            "(Click to highlight in graph)");
    }
    else {
        $("#scaffoldInfoHeader").html("No scaffolds apply to the contigs " +
            "in this connected component.");
    }
    $("#scaffoldInfoHeader").removeClass("notviewable");
    // Perform a few useful operations if the user just loaded this AGP file.
    // These operations are not useful, however, if the AGP file as already
    // been loaded and we just ran updateScaffoldsInComponentList().
    if (agpFileJustLoaded) {
        $("#agpLoadedFileName").html(
            document.getElementById("scaffoldFileSelector").files[0].name);
        $("#agpLoadedFileName").removeClass("notviewable");
        document.getElementById('scaffoldFileSelector').value = "";
        finishProgressBar();
    }
}

// Highlights the contigs within a scaffold by selecting them
function highlightScaffold(scaffoldID) {
    cy.filter(':selected').unselect();
    var contigLabels = SCAFFOLDID2NODELABELS[scaffoldID];
    var nodesToHighlight = cy.collection();
    var nodeToAdd;
    for (var i = 0; i < contigLabels.length; i++) {
        nodeToAdd = cy.filter("[label=\"" + contigLabels[i] + "\"]");
        if (nodeToAdd.empty()) {
            nodeToAdd = cy.getElementById(
                cy.scratch("_ele2parent")[contigLabels[i]]
            );
            if (nodeToAdd === undefined) {
                alert("Invalid node with label " + contigLabels[i] +
                      " detected when highlighting scaffold " + scaffoldID +
                      ".");
            }
        }
        nodesToHighlight = nodesToHighlight.union(nodeToAdd);
    }
    nodesToHighlight.select();
}

// Like searchWithEnter() but for testLayout()
function layoutWithEnter(e) {
    if (e.charCode === 13) {
        testLayout();
    }
}

// Allows user to test one of Cytoscape.js' predefined layouts
function testLayout() {
    if ($("#layoutInput").val() !== "") {
        startIndeterminateProgressBar();
        cy.minZoom(0);
        window.setTimeout(function() {
            // Change to simple bezier edges, since node placement
            // will be changed
            // Adjust min zoom to scope of new layout
            reduceEdgesToStraightLines(false);
            cy.layout({name: $("#layoutInput").val(), fit: true, padding: 0,
                stop: function() {
                    finishProgressBar();
                }
            });
        }, 20);
    }
}

/* Reduces all unbundledbezier edges to basicbezier edges.
 * I guess it'd be nice to eventually add in support to revert these edges to
 * their unbundledbezier forms, but that might require some extra logic
 * (due to collapsing/uncollapsing -- similar to the issues we ran into with
 * hiding/unhiding edges below/above a certain multiplicity).
 *
 * If useProgressBar is true, then an indeterminate progress bar will be
 * started and finished before/after reducing all edges. If useProgressBar is
 * false, then the progress bar will not be triggered.
 */
function reduceEdgesToStraightLines(useProgressBar) {
    if (useProgressBar) {
        startIndeterminateProgressBar();
        window.setTimeout(function() {
            doReduceEdges();
            finishProgressBar();
        }, 50);
    }
    else {
        doReduceEdges();
    }
}

/* Actually does the work of reducing edges. */
function doReduceEdges() {
    cy.startBatch();
    cy.filter("edge").each(
        function(i, e) {
            // We can safely use this even for non-unbundledbezier edges.
            // The reason we don't restrict this loop to unbundledbezier
            // edges is that we want to apply this even to unbundledbezier
            // edges that have been temporarily reduced to basicbezier
            // edges due to node group collapsing.
            e.removeClass("unbundledbezier");
            e.addClass("reducededge");
            e.addClass("basicbezier");
        }
    );
    cy.endBatch();
}

// Simple shortcut used to enable searching by pressing Enter (charCode 13)
function searchWithEnter(e) {
    if (e.charCode === 13) {
        searchForEles();
    }
}

// Centers the graph on a given list of elements separated by commas, with
// spaces optional.
// If any terms entered start with "contig" or "NODE", then this searches on
// node labels for those terms.
function searchForEles() {
    var nameText = $("#searchInput").val();
    if (nameText.trim() === "") {
        alert("Error -- please enter element name(s) to search for.");
        return;
    }
    var names = nameText.split(",")
    var eles = cy.collection(); // empty collection (for now)
    var newEle;
    var parentID;
    var queriedName;
    for (var c = 0; c < names.length; c++) {
        queriedName = names[c].trim();
        if (queriedName.startsWith("contig") || queriedName.startsWith("NODE"))
            newEle = cy.filter("[label=\"" + queriedName + "\"]");
        else
            newEle = cy.getElementById(queriedName);
        if (newEle.empty()) {
            // Check if this element is in the graph (but currently
            // collapsed, and therefore inaccessible) or if it just
            // never existed in the first place
            parentID = cy.scratch("_ele2parent")[queriedName];
            if (parentID !== undefined) {
                // We've collapsed the parent of this element, so identify
                // its parent instead
                eles = eles.union(cy.getElementById(parentID));
            }
            else {
                // It's a bogus element
                alert("Error -- element ID/label " + queriedName +
                      " is not in this component.");
                return;
            }
        }
        else {
            // Identify the node in question
            eles = eles.union(newEle);
        }
    }
    // Fit the graph to the identified names.
    cy.fit(eles);
    // Unselect all previously-selected names
    // (TODO: is this O(n)? because if so, it's not worth it, probably)
    // (Look into this)
    cy.filter(':selected').unselect();
    // Select all identified names, so they can be dragged if desired
    // (and also to highlight them).
    eles.select();
}

/* Determines whether collapsing or uncollapsing should be performed,
 * updates the status div accordingly, and begins the (un)collasping
 * process.
 */
function startCollapseAll() {
    var currVal = $("#collapseButtonText").text();
    startIndeterminateProgressBar();
    window.setTimeout(function() { collapseAll(currVal[0]) }, 50);
}

/* Collapse/uncollapse all compound nodes in the graph.
 * This just delegates to collapseCluster() and uncollapseCluster().
 * An argument of 'U' uncollapses all nodes, and an argument of 'C' (or
 * anything that isn't 'U') collapses all nodes.
 */
function collapseAll(operationCharacter) { 
    cy.startBatch();
    if (operationCharacter === 'U') {
        cy.scratch("_collapsed").each(
            function(i, cluster) {
                uncollapseCluster(cluster);
            }
        );
    }
    else {
        cy.scratch("_uncollapsed").each(
            function(i, cluster) {
                collapseCluster(cluster);
            }
        );
    }
    finishProgressBar();
    cy.endBatch();
}

// Converts an angle in degrees to radians (for use with Javascript's trig
// functions)
function degreesToRadians(angle) {
    return angle * (Math.PI / 180);
}

// Rotates a coordinate by a given clockwise angle (in degrees).
// Returns an array of [x', y'] representing the new point.
function rotateCoordinate(xCoord, yCoord) {
    // NOTE The formula for a coordinate transformation here works for all
    // degree inputs of rotation. However, to save time, we just check
    // to see if the rotation is a factor of 360 (i.e. the rotated
    // point would be the same as the initial point), and if so we just
    // return the original coordinates.
    var rotation = PREV_ROTATION - CURR_ROTATION;
    if (rotation % 360 === 0) {
        return [xCoord, yCoord];
    }
    else {
        var newX = (xCoord * Math.cos(degreesToRadians(rotation)))
                    - (yCoord * Math.sin(degreesToRadians(rotation)));
        var newY = (yCoord * Math.cos(degreesToRadians(rotation)))
                    + (xCoord * Math.sin(degreesToRadians(rotation)));
        newX = parseFloat(newX.toFixed(2));
        newY = parseFloat(newY.toFixed(2));
        return [newX, newY];
    }
}

/* Given the bounding box of the graph, a graph rotation angle (in degrees),
 * and a point specified by x and y coordinates, converts the point from
 * GraphViz' coordinate system to Cytoscape.js' coordinate system, rotating
 * the point if necessary (i.e. the rotation angle mod 360 !== 0).
 *
 * For reference -- GraphViz uses the standard Cartesian system in which
 * the bottom-left corner of the screen is the origin, (0, 0). Cytoscape.js
 * inverts the y-axis, with the origin (0, 0) being situated at the
 * top-right corner of the screen. So to transform a point (x, y) from
 * GraphViz to Cytoscape.js, you just return (x, y'), where
 * y' = the vertical length of the bounding box, minus y.
 * (The x-coordinate remains the same.)
 *
 * This is a purposely simple function -- in the event that we decide to
 * use another graphing library/layout system/etc. for some reason, we can
 * just modify this function accordingly.
 */
function gv2cyPoint(xCoord, yCoord, boundingbox) {
    // Convert from GraphViz to Cytoscape.js
    var cyY = boundingbox[1] - yCoord;
    var cyX = xCoord;
    // Rotate the point about the axis if necessary
    return rotateCoordinate(cyX, cyY);
}

/* Converts a string of control points (defined in the form "x1 y1 x2 y2",
 * for an arbitrary number of points) to a 2-dimensional list of floats,
 * of the form [[x1, y1], [x2, y2], ...]. If the input string contains an
 * odd number of coordinate components for some reason (e.g.
 * "x1 y1 x2 y2 x3") then this will return null, since that's invalid.
 * This also takes care of converting each point in the input string from
 * GraphViz' coordinate system to Cytoscape.js' coordinate system.
 * (Hence why the graph's bounding box and rotation are parameters here.)
 */
function ctrlPtStrToList(ctrlPointStr, boundingbox) {
    // Create coordList, where every coordinate is an element (e.g.
    // [x1, y1, x2, y2, ...]
    var coordList = ctrlPointStr.trim().split(" ");
    // Merge two elements of coordList at a time. NOTE that this is only
    // possible when coordList.length is even, so this is why we have to
    // wait until we're finished parsing all control points until doing
    // this conversion. (If coordList.length is odd, return null --
    // something went very wrong in that case.)
    var clLen = coordList.length;
    if (clLen % 2 !== 0) {
        return null;
    }
    else {
        var pointList = [];
        var currPoint = [];
        for (var i = 0; i < clLen; i++) {
            if (i % 2 === 0) {
                // i/2 is always an integer, since i is even
                pointList[i / 2] = gv2cyPoint(
                        parseFloat(coordList[i]),
                        parseFloat(coordList[i + 1]),
                        boundingbox
                );
            }
        }
        return pointList;
    }
}

// Identifies invalid (per Cytoscape.js) edges and converts them to basic
// bezier edges that can be properly rendered.
// If provided, will only check edgeList.
function fixBadEdges(edgeList) {
    cy.batch(
        function() {
            if (edgeList === undefined) {
                cy.filter('edge.unbundledbezier').each(fixSingleEdge);
            }
            else {
                edgeList.each(fixSingleEdge);
            }
        }
    );
}

/* If the given edge is a badBezier or badLine, converts it to a basicbezier
 * NOTE that this class should be called from within a batch operation, to
 * prevent style class collisions.
 */
function fixSingleEdge(i, e) {
    if (e._private.rscratch['badBezier'] || e._private.rscratch['badLine']) {
        e.removeClass('unbundledbezier');
        e.removeData('cpd');
        e.removeData('cpw');
        e.addClass('basicbezier');
    }
}

/* NOTE -- this is an unused function right now. Could be useful in the future,
 * perhaps.
 * Initializes the adjacent edges (i.e. incoming + outgoing edges) of
 * every non-cluster node in the graph. This would be useful if we
 * enabled dynamic edge validity checking (it makes checking each node's
 * edges more efficient, since we only have to build up these collections
 * once), but for now dynamic edge validity checking is disabled due to
 * still being too slow.
 */
function initNodeAdjacents() {
    cy.filter('node.noncluster').each(
        function(i, node) {
            node.data("adjacentEdges",
                node.incomers('edge').union(node.outgoers('edge'))
            );
        }
    );
}

// Records actual and canonical incoming/outgoing edges of clusters in the
// data of the cluster, as incomingEdges and outgoingEdges (actual
// edges in the graph) and cSource and cTarget (canonical source/target).
// This is going to involve iterating over every compound node in the graph.
// See collapse() for guidance on how to do that, I guess.
// NOTE that we delay doing this work until after everything else has been
// rendered in order to ensure that all edges/nodes necessary for this have
// already been rendered.
function initClusters() {
    // For each compound node...
    cy.scratch("_uncollapsed").each(
        function(i, node) {
            var children = node.children();        
            // Unfiltered incoming/outgoing edges
            var uIncomingEdges = children.incomers('edge');
            var uOutgoingEdges = children.outgoers('edge');
            // Actual incoming/outgoing edges -- will be move()'d as
            // this cluster/adjacent cluster(s) are collapsed/uncollapsed
            var incomingEdges  = uIncomingEdges.difference(uOutgoingEdges);
            var outgoingEdges  = uOutgoingEdges.difference(uIncomingEdges);
            // Mapping of edge ID to [cSource, cTarget]
            // Used since move() removes references to edges, so storing IDs
            // is more permanent
            var incomingEdgeMap = {};
            var outgoingEdgeMap = {};
            // "Canonical" incoming/outgoing edge properties -- these
            // are used to represent the ideal connections
            // between nodes regardless of collapsing
            incomingEdges.each(
                function(j, edge) {
                    incomingEdgeMap[edge.id()] =
                        [edge.source().id(), edge.target().id()];
                }
            );
            outgoingEdges.each(
                function(j, edge) {
                    outgoingEdgeMap[edge.id()] =
                        [edge.source().id(), edge.target().id()];
                }
            );
            // Get the "interior elements" of the cluster: all child nodes,
            // plus the edges connecting child nodes within the cluster
            // This considers cyclic edges (e.g. the edge connecting a
            // cycle's "end" and "start" nodes) as "interior elements,"
            // which makes sense as they don't connect the cycle's children
            //  to any elements outside the cycle.
            var interiorEdges = children.connectedEdges().difference(
                incomingEdges).difference(outgoingEdges);
            var wid = 0;
            var hgt = 0;
            // Basically, a cluster's width and height should be
            // reflective of the widths and heights of its children.
            // In the children.each block here we basically add the
            // approximate DNA lengths of each child (as reflected
            // in the width/height of the child node in question) to
            // an accumulator, and after the block we treat these
            // values like we treat normal node blocks and scale them
            // the same way (logarithmically).
            children.each(function(i,e) {
                wid += Math.pow(10, e.data("w") / INCHES_TO_PIXELS);
                hgt += Math.pow(10, e.data("h") / INCHES_TO_PIXELS);
            });
            wid = INCHES_TO_PIXELS * (Math.log(wid) / Math.log(10));
            hgt = INCHES_TO_PIXELS * (Math.log(hgt) / Math.log(10));
            // Record incoming/outgoing edges in this
            // cluster's data. Will be useful during collapsing.
            // We also record "interiorNodes" -- having a reference to just
            // these nodes saves us the time of filtering nodes out of
            // interiorEles when rotating collapsed node groups.
            node.data({
                "incomingEdgeMap"   : incomingEdgeMap,
                "outgoingEdgeMap"   : outgoingEdgeMap,
                "w"                 : wid,
                "h"                 : hgt,
                "interiorNodeCount" : children.size()
            });
            // We store collections of elements in the cluster's scratch data.
            // Storing it in the main "data" section will mess up the JSON
            // exporting, since it isn't serializable.
            // TODO reduce redundancy here -- only store interiorEles, and in
            // rotateNodes just select nodes from interiorEles
            node.scratch({
                "_interiorEles": interiorEdges.union(children),
                "_interiorNodes": children
            });
        }
    );
}

// returns the coordinate class for a cluster node in the graph (only
// respective to left/right vs. up/down direction)
function getClusterCoordClass() {
    if (CURR_ROTATION === 0 || CURR_ROTATION === 180) {
        return "updowndir";
    }
    else {
        return "leftrightdir";
    }
}

// returns the coordinate class for a noncluster node in the graph
function getNodeCoordClass(isHouse) {
    switch (CURR_ROTATION) {
        case 0:
            return isHouse ? "updir" : "downdir";
        case 90:
            return isHouse ? "leftdir" : "rightdir";
        case 180:
            return isHouse ? "downdir" : "updir";
        case 270:
            return isHouse ? "rightdir" : "leftdir";
    }
}

// Renders a given node object, obtained by getAsObject() from running a
// query on CURR_DB for selecting rows from table nodes.
// Returns the new (in Cytoscape.js coordinates) position of the node.
function renderNodeObject(nodeObj, boundingboxObject) {
    var pos = gv2cyPoint(nodeObj['x'], nodeObj['y'],
        [boundingboxObject['boundingbox_x'],
         boundingboxObject['boundingbox_y']]);
    var isHouse = nodeObj['shape'] === 'house';
    var nodeID = nodeObj['id'];
    var nodeLabel = nodeObj['label'];
    COMPONENT_NODE_LABELS.push(nodeLabel);
    // NOTE that NULL in sqlite gets translated to Javascript as null, which
    // works perfectly for our use of the node parent field.
    // Hence why we can just use the parent_cluster_id field directly.
    var parentID = nodeObj['parent_cluster_id'];
    var gc = nodeObj['gc_content'];
    var bg_color = "#";
    if (gc !== null && gc !== undefined) {
        var red_i = gc * 255;
        var green = "22";
        var blue_i = 255 - red_i;
        var red = Math.floor(red_i).toString(16);
        var blue = Math.floor(blue_i).toString(16);
        if (red.length === 1) {
            red = "0" + red;
        }
        if (blue.length === 1) {
            blue = "0" + blue;
        }
        bg_color += (red + green + blue);
    }
    else {
        bg_color += "999999";
    }
    var labelUsed = (nodeLabel === null) ? nodeID : nodeLabel;
    cy.add({
        classes: 'noncluster' + ' ' + getNodeCoordClass(isHouse),
        data: {id: nodeID, parent: parentID, label: labelUsed,
               w: INCHES_TO_PIXELS * nodeObj['h'],
               h: INCHES_TO_PIXELS * nodeObj['w'],
               // TODO: the "house" parameter might be too expensive?
               house: isHouse, depth: nodeObj['depth'],
               // TODO: if we settle on always calculating G/C content when DNA
               // is available, then we can use the gc_content variable as a
               // flag for null instead of the explicit hasDNA data value.
               length: nodeObj['length'], hasDNA: nodeObj['dnafwd'] !== null,
               gc_content: gc, bg_color: bg_color},
        position: {x: pos[0], y: pos[1]}
    });
    if (parentID !== null) {
        cy.scratch("_ele2parent")[nodeID] = parentID;
        // Allow for searching via node labels. This does increase the number
        // of entries in _ele2parent by |Nodes| (assuming every node in the
        // graph has a label given) -- so if that is too expensive for some
        // reason, I suppose this could be disallowed.
        if (nodeLabel !== null)
            cy.scratch("_ele2parent")[nodeLabel] = parentID;
    }
    return pos;
}

// Draws two nodes that "enforce" the given bounding box.
function drawBoundingBoxEnforcingNodes(boundingboxObject) {
    var bb = [boundingboxObject['boundingbox_x'],
              boundingboxObject['boundingbox_y']];
    var bottomLeftPt = gv2cyPoint(0, 0, bb);
    var topRightPt = gv2cyPoint(bb[0], bb[1], bb);
    cy.add({
        classes: "bb_enforcing", data: {id: "bottom_left"},
        position: {x: bottomLeftPt[0], y: bottomLeftPt[1]}
    });
    cy.add({
        classes: "bb_enforcing", data: {id: "top_right"},
        position: {x: topRightPt[0], y: topRightPt[1]}
    });
}

function removeBoundingBoxEnforcingNodes(boundingboxObject) {
    cy.$("node.bb_enforcing").remove();
}

// Renders a cluster object.
function renderClusterObject(clusterObj, boundingboxObject) {
    var clusterID = clusterObj["cluster_id"];
    var bottomLeftPos = gv2cyPoint(clusterObj['left'], clusterObj['bottom'],
        [boundingboxObject['boundingbox_x'],
         boundingboxObject['boundingbox_y']]);
    var topRightPos = gv2cyPoint(clusterObj['right'], clusterObj['top'],
        [boundingboxObject['boundingbox_x'],
         boundingboxObject['boundingbox_y']]);
    cy.scratch("_uncollapsed", cy.scratch("_uncollapsed").union(
        cy.add({
            classes: clusterID[0] + ' cluster ' + getClusterCoordClass(),
            data: {id: clusterID,
                w: Math.abs(topRightPos[0] - bottomLeftPos[0]),
                h: Math.abs(topRightPos[1] - bottomLeftPos[1]),
                isCollapsed: false},
            position: {x: (bottomLeftPos[0] + topRightPos[0]) / 2,
                       y: (bottomLeftPos[1] + topRightPos[1]) / 2}
        })
    ));
}

/* Renders edge object. Hopefully in a not-terrible way.
 *
 * Uses node2pos (mapping of node object from DB -> [x, y] position)
 * to calcluate relative control point weight stuff.
 *
 * This also relatively scales edge thickness based on multiplicity.
 * NOTE that we don't scale edge thickness when using dot from collate.py,
 * since GraphViz doesn't adjust node placement based on edge thickness even
 * in extreme cases -- therefore we have free reign in this function to
 * adjust edge thickness, independent of the other parts of AsmViz.
 */
function renderEdgeObject(edgeObj, node2pos, maxMult, minMult,
        boundingboxObject) {
    var sourceID = edgeObj['source_id'];
    var targetID = edgeObj['target_id'];
    var multiplicity = edgeObj['multiplicity'];
    var thickness = edgeObj['thickness'];
    var orientation = edgeObj['orientation'];
    var mean = edgeObj['mean'];
    var stdev = edgeObj['stdev'];
    // If bundle sizes are available, then don't show edges with a bundle size
    // below a certain threshold. NOTE that this feature is disabled for the
    // time being, but can be reenabled eventually (consider adding a minimum
    // bundle size threshold that is configurably by the user; also, rewrite
    // to focus on multiplicity instead of bundlesize since the two terms are
    // basically equivalent)
    //var bundlesize = edgeObj['bundlesize'];
    //if (bundlesize !== null && bundlesize < MIN_BUNDLE_SIZE) {
    //    return;
    //}

    var edgeWidth;
    if (thickness !== null) {
        // Scale edge thickness using the "thickness" .db file attribute
        // (If edge thickness data is available)
        edgeWidth = MIN_EDGE_THICKNESS + (thickness*EDGE_THICKNESS_RANGE);
        var edgeID = sourceID + "->" + targetID;
        if (edgeObj['parent_cluster_id'] !== null) {
            cy.scratch("_ele2parent")[edgeID] = edgeObj['parent_cluster_id'];
        }
    }
    else {
        // Assign each edge a uniform thickness
        edgeWidth = MAX_EDGE_THICKNESS;
    }
    if (sourceID === targetID) {
        // It's a self-directed edge; don't bother parsing ctrl pt
        // info, just render it as a bezier edge and be done with it
        cy.add({
            classes: "basicbezier",
            data: {id: edgeID, source: sourceID, target: targetID,
                   thickness: edgeWidth, multiplicity: multiplicity,
                   orientation: orientation, mean: mean, stdev: stdev}
        });
        return;
    }
    var srcPos = node2pos[sourceID];
    var tgtPos = node2pos[targetID];
    var srcSinkDist = distance(srcPos, tgtPos);
    var ctrlPts = ctrlPtStrToList(edgeObj['control_point_string'],
            [boundingboxObject['boundingbox_x'],
             boundingboxObject['boundingbox_y']]);
    var ctrlPtLen = edgeObj['control_point_count'];
    var nonzero = false;
    var ctrlPtDists = "";
    var ctrlPtWeights = "";
    var currPt, dsp, dtp, w, ws, wt, nonzero;
    for (var p = 0; p < ctrlPtLen; p++) {
        currPt = ctrlPts[p];
        // TODO inefficiency here -- rework pointToLineDistance.
        var d = -pointToLineDistance(currPt,
            {x: srcPos[0], y: srcPos[1]}, {x: tgtPos[0], y: tgtPos[1]});
        dsp = distance(currPt, srcPos);
        dtp = distance(currPt, tgtPos);
        // By the pythagorean thm., the interior of the square root
        // below should always be positive -- the hypotenuse must
        // always be greater than both of the other sides of a right
        // triangle.
        // However, due to Javascript's lovely (...)
        // type system, rounding errors can cause the hypotenuse (dsp
        // or dtp)
        // be represented as slightly less than d. So, to account for
        // these cases, we just take the abs. value of the sqrt body.
        // NOTE that ws = distance on line to source;
        //           wt = distance on line to target
        ws = Math.sqrt(Math.abs(Math.pow(dsp, 2) - Math.pow(d, 2)));
        wt = Math.sqrt(Math.abs(Math.pow(dtp, 2) - Math.pow(d, 2)));
        // Get the weight of the control point on the line between
        // source and sink oriented properly -- if the control point is
        // "behind" the source node, we make it negative, and if the
        // point is "past" the sink node, we make it > 1. Everything in
        // between the source and sink falls within [0, 1] inclusive.
        if (wt > srcSinkDist && wt > ws) {
            // The ctrl. pt. is "behind" the source node
            w = -ws / srcSinkDist;
        }
        else {
            // The ctrl. pt. is anywhere past the source node
            w = ws / srcSinkDist;
        }
        // If we detect all of the control points of an edge are less
        // than some epsilon value, we just render the edge as a normal
        // bezier (which defaults to a straight line).
        if (Math.abs(d) > CTRL_PT_DIST_EPSILON) {
            nonzero = true;
        }
        // Control points with a weight of 0 (as the first ctrl pt)
        // or a weight of 1 (as the last ctrl pt) aren't valid due
        // to implicit points already "existing there."
        // (See https://github.com/cytoscape/cytoscape.js/issues/1451)
        // This preemptively rectifies such control points.
        if (p === 0 && w === 0.0) {
            w = 0.01;
        }
        else if (p === (ctrlPtLen - 1) && w === 1.0) {
            w = 0.99;
        }
        ctrlPtDists += d.toFixed(2) + " ";
        ctrlPtWeights += w.toFixed(2) + " ";
    }
    ctrlPtDists = ctrlPtDists.trim();
    ctrlPtWeights = ctrlPtWeights.trim();
    if (nonzero) {
        // The control points should (hopefully) be valid
        cy.add({
            classes: "unbundledbezier",
          data: {id: edgeID, source: sourceID, target: targetID,
                 cpd: ctrlPtDists, cpw: ctrlPtWeights,
                 thickness: edgeWidth, multiplicity: multiplicity,
                 orientation: orientation, mean: mean, stdev: stdev}
        });
    }
    else {
        // The control point distances are small enough that
        // we can just represent this as a straight bezier curve
      cy.add({
          classes: "basicbezier",
          data: {id: edgeID, source: sourceID, target: targetID,
                 thickness: edgeWidth, multiplicity: multiplicity,
                 orientation: orientation, mean: mean, stdev: stdev}
      });
    }
}

/* Given two points, each in the form [x, y], returns the distance between
 * the points obtained using d = sqrt((x2 - x1)^2 + (y2 - y1)^2).
 * e.g. distance([1, 2], [3, 4]) = sqrt((3 - 1)^2 + (4 - 2)^2) = sqrt(8)
 */
function distance(point1, point2) {
    return Math.sqrt(
              Math.pow(point2[0] - point1[0], 2)
            + Math.pow(point2[1] - point1[1], 2)
    );
}

/* Given a line that passes through two Nodes -- lNode1 and lNode2
 * -- this function returns the perpendicular distance from a point to the
 * line.
 */
function pointToLineDistance(point, lNode1, lNode2) {
    var lDist = distance([lNode1.x, lNode1.y], [lNode2.x, lNode2.y]);
    if (lDist === 0) {
        return 0;
    }
    var ydelta = lNode2.y - lNode1.y;
    var xdelta = lNode2.x - lNode1.x;
    var consts = (lNode2.x * lNode1.y) - (lNode2.y * lNode1.x);
    var numer = (ydelta * point[0]) - (xdelta * point[1]) + consts;
    return numer / lDist;
}
